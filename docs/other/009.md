# 性能优化(2)

## 核心指标

1. 加载速度：LCP，即最核心内容绘制时长，也是用户感受最明显的，其不应该超过 2.5 秒
2. 视觉稳定性：CLS，即累积布局偏移，简单说就是页面抖动严重程度，其不应该超过 0.1
3. 交互响应性：INP,每次交互到下一次绘制的时长，其不应该超过 200 毫秒，取代了之前的 FID(只有首次交互)

## 获取性能数据

卡顿是用户感知上的，我们需要将其转换为技术语言，以便优化。

性能数据分为：

- 实验室数据(开发调试环境)：通过 dev tool 的 lighthouse 工具跑报告
- 现场数据(真实线上环境)：通过线上监控获取，比如谷歌的 web-vitals 库

## 线上卡顿，本地无问题

### 解决方案

1. 让用户清除缓存
2. 在本地模拟用户环境，比如相同的浏览器版本，工单上的操作步骤

如果上述 2 种方式都不能复现或者解决问题，则需要基于真实的用户监控（RUM 体系）去排查。排查路径遵循闭环：

1. 量化性能：采集用户真实的性能指标，异常日志和环境信息
2. 捕获异常：数据上报监控平台，通过数据可视化和聚合分析找到异常位置和共性
3. 还原现场：提出假设，回到本地用开发者工具精准模拟线上环境

## script 导致页面加载缓慢

本质问题：浏览器渲染被阻塞，原因是浏览器默认遇到 script 会暂停一切工作，去下载并执行脚本。

思路：先看依赖再定策略

首先看脚本是否依赖 DOM

- 不依赖 DOM：async 属性，并行下载脚本，下载完立刻执行;滥用会导致执行顺序混乱，引发偶发性 bug
- 依赖 DOM:defer 属性，并行下载脚本，并在 html 解析完执行;不会阻塞渲染的同时又可以保证依赖关系

async 属性适用于独立的脚本，比如广告脚本和分析脚本，defer 适用于依赖 DOM 或者其他脚本内容的脚本

## 资源提示符

语法：`<link rel="" href="" as=""/>`

区别维度：

- 时机：服务于 当前页面还是未来可能访问的页面
- 深度: 解析域名/建立完整连接/加载资源

### 含义及场景

- 第三方域名解析
  1. dns-prefetch:针对未来的请求，提前将域名解析为 ip 地址，适用于非关键的第三方域名，例如数据分析脚本域名或者社交插件域名
  2. preconnect:提前完成 DNS 解析并建立安全连接通道(TCP 握手、TRS 协商)，当实际请求时可以省去创建连接的时间，适用于会很快用到并且对当前页面至关重要的第三方域名，例如字体库、CDN 域名、核心 API 域名
- 资源下载
  1. preload:必须和 as 属性配合使用，强制浏览器优先下载该资源，但先不执行，适用于解决隐藏较深但对当前页面渲染至关重要的资源加载问题，比如 css 文件中的 font-face，LCP 中的大图加载
  2. prefetch:优化未来资源的加载体验，浏览器空闲时间低优先级下载，存进缓存;比如在第一页 prefetch 第二页的资源，单页应用中，当用户鼠标悬停某个路径上,prefetch 对应的路由

## http 缓存 vs serviceWorker

二者都可以实现缓存，区别是控制权的问题。

http 缓存是完全由服务器通过浏览器的响应头和请求头控制，适用于缓存 几乎不会变的静态资源；serviceWorker 由开发者自定义代码控制，可定制性高但复杂度也会较高，适用于缓存 动态逻辑和离线应用；二者可以是合作关系，

```js
// Service Worker 中的优化策略
self.addEventListener("fetch", (event) => {
  const request = event.request;

  // 1. 静态资源：依赖HTTP缓存，SW只做回退
  if (request.url.includes("/static/")) {
    event.respondWith(
      fetch(request).catch(() => caches.match("/offline-static.html"))
    );
    return;
  }

  // 2. API数据：HTTP设置短缓存，SW实现智能缓存
  if (request.url.includes("/api/")) {
    event.respondWith(
      // 自定义缓存策略：5分钟内使用缓存
      caches.open("api-data").then((cache) => {
        return cache.match(request).then((cached) => {
          if (cached && Date.now() - cached.headers.get("sw-time") < 300000) {
            return cached; // 5分钟内使用缓存
          }
          return fetch(request).then((networkResponse) => {
            // 更新缓存
            const cloned = networkResponse.clone();
            cache.put(request, cloned);
            return networkResponse;
          });
        });
      })
    );
  }
});
```

## CDN 提升网站加载速度

思路：分析(分析现象)->分类(定位问题根源)->给出方案(针对性优化)

1. 物理距离远：引入 CDN，用空间换时间
2. 原站服务器负载高：重点看 CPU 和网络出口，原站只负责动态请求和回源，其余交给 CDN
3. 静态资源加载慢：将静态资源放到 CDN 的边缘节点，提升访问速度

总原则：动静分离

- 所有静态资源包括(css,js，图片)都放在 CDN 的边缘节点，让用户就近快速获取
- 优化 CDN 缓存策略：根据业务需求调整缓存时间，提升命中率

## 首屏加载慢甚至出现白屏怎么解决

1. 先看网络/CDN → 排除传输瓶颈
2. 看骨架屏 → 判断 JS 是否开始执行
3. 分析资源加载慢点 → 找出阻塞首屏的主要资源
4. 针对不同类型优化 → JS/CSS/图片/渲染/接口
5. 验证与迭代 → 指标改善才算解决
