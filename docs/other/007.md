# 前端性能优化

## 通用性能优化

方向 1：加载更快

1. 减少资源体积：压缩代码以及图片体积
2. 减少访问次数：合并代码，ssr 渲染(页面+数据)，利用缓存
3. 加快网络速度：CDN

方向 2：渲染更快

1. CSS 放在 head,script 放在 body
2. 尽早执行 JS,在 dom 加载完成后就执行
3. 使用懒加载：图片懒加载，上滑加载更多
4. DOM 查询进行缓存，合并 DOM 操作
5. 使用节流和防抖

## 缓存

静态资源添加 hash 后缀，文件不变则 hash 不变,从而请求的 url 也不会变，就会触发缓存返回 304

## 防抖&节流

### 防抖 debounce：

原理：在事件被触发后，等待一段时间再执行回调，如果期间事件又被触发则重新计时

场景：

1. 搜索框输入联想
2. 窗口大小调整（resize）
3. 滚动监听：业务希望加载完成再显示
4. 按钮防止重复点击：表单提交

```js
function debounce(fn, delay = 500) {
  let timer;
  return function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, delay);
  };
}

const debouncedFn = debounce(originalFn, delay);
element.addEventListener("event", debouncedFn);
```

### 节流 throttle

场景：

1. 滚动加载（scroll）：持续检测是否触底
2. 浏览器窗口 resize 控制重绘和重新布局频率
3. 按钮连续点击，防止重复触发请求：支付、提交接口等，需要立即响应一次点击，但短时间内禁止重复触发；“点赞”按钮，每隔 1 秒只允许一次点击。
4. 拖拽元素，获取该元素位置

原理：在一段时间内，只允许函数执行一次。无论事件触发多少次，都按照固定的时间间隔执行。

```js
function throttle(fn,delay){
    let timer
    return function(fn.delay){
        if(timer) return
        timer=setTimeout(()=>{
            fn.apply(this,arguments)
            timer=null
        },delay)
    }
}
```

::: tip
Q:将 timer 设置为 null，和 clearTimeout(timer)有什么区别

A:：clearTimeout 取消已经创建的定时器，定时器的回调函数不会再执行，但 timer 变量本身 不会被自动清空，仍然保存着定时器的 ID。而 timer 重置为 null，回调依旧会执行
:::

---

进阶：https://space.bilibili.com/3546718784195328/search?keyword=%E6%80%A7%E8%83%BD
