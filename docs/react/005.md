# react 状态管理

## setState 是异步 or 同步

setState 是同步提交，延迟执行：setState 函数本身是同步的，但他触发的状态更新和组件重渲染，会被 react 延迟处理和批量合并；

将多次状态更新合并为单次渲染，避免了不必要的计算和 DOM 操作，优化了应用性能；

保证在一次事件处理流程中，所有状态能够同步生效，防止出现不完整的中间 UI 状态，提升应用的健壮性。

### React 批量更新策略：

react 会将同一次事件循环中的所有 setState 调用搜集起来，放入一个队列，在事件函数执行完毕后，将所有状态更新合并，只进行一次重渲染。

React18 前，批量更新局限于 React 自身的事件处理器中，而 react18 后 setTimeout,promise 回调函数中也支持了自动批量更新。

## useState 两种更新状态的方式

1. 直接传入新的值`setCount(1)`
2. 传入一个函数，即函数式更新`setCount(prev=>prev+1)`

```jsx
import { useState } from "react";

const Demo = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
  };
  return (
    <>
      <div>{count}</div>
      <button onClick={handleClick}>+1</button>
    </>
  );
};

export default Demo;
```

我们预期每点击一次，count 增加 3，但实际上，最终 count 显示的是 1。原因是：

1. state 闭包陷阱：函数作用域内的 count 值，永远是当次渲染的快照 0
2. 异步与批处理：react 会将短时间内的多次 setState 调用合并处理，以优化性能

模式选择：如果新的 state 依赖旧的 state，使用函数式更新；其他情况下选择值更新

## 状态提升

核心：将多个兄弟组件共享的 state,移动到最近的共同父组件中，由父组件统一管理

::: code-group

```jsx [父组件]
import { useState } from "react";
import TempInput from "./TempInput";

const Demo = () => {
  const [temp, setTemp] = useState("");
  const [scale, setScale] = useState("c");
  const handleCelisChange = (num: string) => {
    setTemp(num);
    setScale("c");
  };
  const handleFelisChange = (num: string) => {
    setTemp(num);
    setScale("f");
  };
  const celsius = scale === "f" ? tryConvert(temp, toCelsius) : temp;
  const fahrenheit = scale === "c" ? tryConvert(temp, toFahrenheit) : temp;
  return (
    <>
      <TempInput scale="c" temp={celsius} onTempChange={handleCelisChange} />
      <TempInput scale="f" temp={fahrenheit} onTempChange={handleFelisChange} />
    </>
  );
};
```

```jsx [子组件]
const TempInput = (props: TProps) => {
  const { scale, temp, onTempChange } = props;
  const onChange = (event: any) => {
    onTempChange(event.target.value);
  };
  return (
    <div>
      <input value={temp} onChange={onChange} />
      {scale}
    </div>
  );
};
```

```js [util函数]
// 摄氏度 ↔ 华氏度 转换函数
const toCelsius = (f: number) => ((f - 32) * 5) / 9;
const toFahrenheit = (c: number) => (c * 9) / 5 + 32;

// 转换 + 格式化函数
const tryConvert = (value: string, convert: (v: number) => number): string => {
  const num = parseFloat(value);
  if (Number.isNaN(num)) return "";
  const output = convert(num);
  return (Math.round(output * 100) / 100).toString(); // 保留两位小数
};
```

:::

## useReducer

## useContext

## redux
