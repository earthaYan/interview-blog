# 路由系统

## hash 和 history 模式的核心区别

|                        | hash 模式                         | history 模式        |
| ---------------------- | --------------------------------- | ------------------- |
| url 变化触发服务器请求 | 不会                              | 会                  |
| url 表现形式           | /#/home,#后面的内容只在前端生效   | /home               |
| 实现原理               | location.hash/window.onhashchange | H5 的 History API   |
| 服务器配置             | 不需要，服务器只返回 index.html   | 要，需要做 fallback |

## 两种模式的优缺点

### hash 模式

优点：

1. 完全前端控制，不需要服务器配置
2. 刷新不会 404
3. 兼容性最好（IE8+）

缺点：

1. URL 不够优雅
2. SEO 不友好（# 后面搜索引擎不抓取）
3. state 表达能力弱（只能通过 hash）

### history 模式

优点：

1. URL 更优雅、规范
2. 功能更强（pushState 可存状态）,比如 useNavigate

缺点：

1. 需要服务器配置区分前端路由和后端路由
2. 刷新未配置 fallback 会出现 404

::: tip
浏览器访问 /about 时，服务器默认会找 /about 文件或路径，如果服务器没有配置 fallback，会找不到。所以通常需要把 所有前端路由 fallback 到 index.html，让 React Router 接管路由
:::

## 使用场景

- history 模式：需要 SEO 场景,企业后台管理系统
- hash 模式：纯前端 SPA + 静态托管（无后端），要兼容低版本浏览器

## hash 模式

#后面的部分属于 URL 的锚点，是浏览器内部使用，不会被发送给服务器，所以浏览器不会重新加载资源，而只会触发 hashChange 事件，监听该事件并切换组件。

## history 模式

```sh
location / {
  try_files $uri /index.html;
}

```

History 模式的 pushState 是添加一条记录,replaceState 是替换当前记录

### B 端常用 api

| 功能         | API                                                 |
| ------------ | --------------------------------------------------- |
| 路由容器     | `BrowserRouter`                                     |
| 声明式导航   | `Link`, `NavLink`                                   |
| 编程式导航   | `const navigate=useNavigate() ;navigate(-1/1)`      |
| 获取路径     | `useLocation()`, `useParams()`, `useSearchParams()` |
| 页面跳转控制 | `Navigate`, `replace`                               |
| 嵌套路由     | `Route` 嵌套 + `Outlet`                             |
