---
outline: deep
---

# useEffect,useLayoutEffect

- 渲染：将 state/props 计算成 UI,这是纯操作，无副作用
- 副作用：渲染过程中做了“额外事情”，可能会影响组件外的状态或系统，包括数据获取，dom 操作，事件监听，定时器，本地存储变更，触发全局状态变化等

## useEffect 依赖项数组

- 无依赖数组：组件每次渲染后都会重新执行副作用函数
- 空依赖数组：仅在第一次渲染后执行一次
- 非空依赖数组：依赖项变化时候执行

工作原理：

1. 每次 useEffect 执行后，react 会在内部保存下本次的依赖项数组
2. useEffect 再次被调用，react 会将新传入的依赖项数组和上次的数据进行逐项浅比较`Object.is()`
3. 如果所有依赖型都相等则跳过，否则执行副作用函数

### 内部实现：

useEffect 在 render 阶段不会执行，React 只会把它记录到 fiber 的 effect 链表里。在 commit 阶段结束后，React 通过 scheduler 异步执行这些副作用。执行顺序是 “先 destroy 再 create”，只有依赖变化才重新执行。
useEffect 之所以是异步的，是为了不阻塞 DOM 渲染，避免影响用户体验。
而 useLayoutEffect 会在布局阶段同步执行。

## useEffect 和 useLayoutEffect

执行过程:

状态变化(prop/state)->渲染阶段->计算新 VDOM->提交阶段 commit->更新真实 DOM->**useLayoutEffect 执行**->浏览器根据 DOM 进行绘制->**useEffect 执行**

区别：useLayoutEffect 是同步任务，在浏览器绘制之前执行，会阻塞浏览器绘制；useEffect 是异步任务，在浏览器绘制完成后执行，不会阻塞浏览器绘制

useEffect 的优势在于性能方面，他不会阻塞浏览器绘制，界面响应快，适合用在大部分场景下。

useLayoutEffect 的优势在于精准控制，他是浏览器绘制之前最后一次修改 DOM 的机会，避免用户界面出现闪烁现象，确保用户看到的是正确状态，一般只用于 DOM 修改、布局方面的轻量调整。

需要注意的是 useLayoutEffect 在服务端不会执行，所以在 ssr 场景下使用可能会导致首屏渲染出问题。

如何避免一些问题：使用 eslint-plugin-react-hooks 插件，启用 rules-of-hooks/exhaustive-deps 这两个规则

## useEffect 内部的异步请求

清理机制：useEffect 可以返回一个函数，用来清理上次副作用带来的影响，比如解绑事件监听，清理定时器。

清理函数执行时机：

1. 组件卸载时执行
2. 依赖项变化，在下一次 effect 之前执行

竞态条件：先后发送两个请求，由于网络等原因，先请求的数据反而后响应。

造成问题：

1. 状态错乱：界面上最终显示的是前一个请求的响应内容，和用户预期不一致
2. 内存泄漏警告：当前组件已经卸载，但请求响应回来的时候仍然试图修改已卸载组件的状态

解决方案：利用 useEffect 的清理机制在清理函数里取消请求

::: code-group

```js [布尔标记]
useEffect(() => {
  let isMounted = true;

  fetchData().then(() => {
    if (isMounted) {
      setData(1);
    }
  });
  return () => {
    isMounted = false;
  };
}, [id]);
```

```js [AbortController]
useEffect(() => {
  const controller = new AbortController();

  axios
    .get("/api/data", { signal: controller.signal /**传递signal */ })
    .then((res) => setData(res.data))
    .catch((err) => {
      // 处理取消请求
      if (axios.isCancel?.(err) || err.name === "CanceledError") return;
      console.error(err);
    });
  return () => {
    // 清理函数中取消请求
    controller.abort();
  };
}, []);
```

:::

优先选择 AbortController 方案，因为布尔标记的方案虽然解决了竞态请求的问题，但是并没有实际上取消 http 请求，还是会造成资源和带宽的浪费；而后者是实际上取消了请求，并且他是浏览器原生 API，不需要额外安装第三方库.
