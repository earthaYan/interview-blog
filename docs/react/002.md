---
outline: deep
---

# JSX 以及组件类型

## 对 jsx 的理解

1. jsx 是 JS 语法的扩展，本质上是 React.CreateElement()或者\_jsx()的语法糖，提供了更具可读性的声明式写法
2. jsx 不能直接被浏览器识别，需要通过 babel 等工具将其转译成 js 代码，即最终的产物是 JS 对象，这也是 React 虚拟 DOM 的基础
3. jsx 虽然形式上像在 js 里写 html 代码，但实际上不属于模板语法，而是融合了 js 的全部能力来构建复杂的应用界面

## 函数组件/类组件

简单来说，`函数组件+hooks≈class 组件`,但这只是表面分别，实际上其设计哲学和心智模型是完全不一样的。

class 组件体现的是面向对象思想，属于实例思维。React 会 new 一个组件实例，这个实例有自己的生命周期和内部状态以及方法；开发者只能通过 this 这个可变指针管理组件实例的 props 和 state，相当于在操作一个长期存在且状态可变的实例。

function 组件体现的是函数式编程思想，每次渲染，react 就会重新调用这个纯函数；每一次渲染都是一个独立的快照,函数内部所有状态都被固定在那一刻，同时开发者通过 hooks 管理 props 和 state。
::: code-group

```js [class组件]
import React from "react";
//点击3次最终会弹出3次alert，count值均为3
class Counter extends React.PureComponent {
  state = { count: 0 };

  logMessage = () => {
    setTimeout(() => {
      alert(`count is ${this.state.count}`);
    }, 2000);
  };

  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
    this.logMessage();
  };

  render() {
    return (
      <>
        <div>{this.state.count}</div>
        <button onClick={this.handleClick}>+1</button>
      </>
    );
  }
}

export default Counter;
```

```js [函数组件]
import { useState } from "react";
//点击3次最终会弹出3次alert，count值均为0，1，2
const Demo = () => {
  const [count, setCount] = useState(0);
  const logMessage = () => {
    setTimeout(() => {
      alert(`count is ${count}`);
    }, 2000);
  };
  const handleClick = () => {
    setCount(count + 1);
    logMessage();
  };
  return (
    <>
      <div>{count}</div>
      <button onClick={handleClick}>+1</button>
    </>
  );
};

export default Demo;
```

:::
上述代码中，函数式组件由于闭包原因，每次点击，都会创建新的 logMessage 函数，这个函数是在某次特定渲染中定义的，他会捕获当前所在作用域的 count 值。

class 组件围绕生命周期为中心，将逻辑分散到不同的生命周期函数中。而 function 组件通过 useEffect 处理副作用，数据获取和清理工作相关的逻辑可以聚合到一起。

目前 class 组件只适合用在 errorBoundary 组件。

## class 组件生命周期

React 类组件生命周期分三个阶段：

- 挂载：组件创建并插入 DOM，依次调用 constructor → render → componentDidMount，常用于初始化 state、绑定方法、发请求
- 更新：当 props 或 state 变化时触发，调用顺序是 shouldComponentUpdate → render →componentDidUpdate，可用于控制渲染、获取 DOM 信息或发请求。
- 卸载：组件移除时调用 componentWillUnmount，用于清理定时器、取消订阅等资源。

此外，React 16+ 支持错误处理生命周期 getDerivedStateFromError 和 componentDidCatch，用于捕获子组件渲染错误并显示备用 UI。

## HOC 和 render props 区别

1. 高阶组件（HOC）
   - 本质：纯函数，接收组件返回增强型新组件，核心是「组件级复用」—— 通过包装原组件注入状态、逻辑、props；
   - 核心问题：易出现 props 冲突、嵌套地狱，且封装的逻辑无法动态调整；
   - 适用场景：适合全局通用逻辑封装（如 withFetch 请求封装、withAuth 权限控制）。
2. Render Props
   - 本质：组件设计模式，通过值为函数的 prop（如 render/children）暴露内部逻辑，核心是「逻辑级复用」—— 外部自主决定渲染内容；
   - 核心问题：语法稍繁琐，若回调定义在 render 中易导致子组件重复渲染（需 useCallback 优化）；
   - 核心优势：无 props 冲突，灵活性更高。

总结
二者均解决逻辑复用问题，但 HOC 侧重「组件增强」，Render Props 侧重「逻辑传递」；React 16.8 后推出的 Hooks（如 useState/useEffect）以更细的粒度、无嵌套 / 冲突的优势，已成为当前开发中替代二者的主流方案。
::: code-group

```jsx [hoc实现]
// 定义HOC：封装鼠标位置逻辑
const withMousePosition = (WrappedComponent) => {
  return class extends React.Component {
    state = { x: 0, y: 0 };

    handleMouseMove = (e) => {
      this.setState({ x: e.clientX, y: e.clientY });
    };

    componentDidMount() {
      window.addEventListener("mousemove", this.handleMouseMove);
    }
    componentWillUnmount() {
      window.removeEventListener("mousemove", this.handleMouseMove);
    }

    render() {
      // 把鼠标位置注入给原组件
      return <WrappedComponent {...this.props} mouse={this.state} />;
    }
  };
};

// 使用HOC
const MouseTracker = withMousePosition(({ mouse }) => (
  <div>
    鼠标位置：{mouse.x}, {mouse.y}
  </div>
));
//使用增强组件
<MouseTracker />;
```

```jsx [render props]
// 定义Render Props组件：封装鼠标位置逻辑
class MousePosition extends React.Component {
  state = { x: 0, y: 0 };

  handleMouseMove = (e) => {
    this.setState({ x: e.clientX, y: e.clientY });
  };

  componentDidMount() {
    window.addEventListener("mousemove", this.handleMouseMove);
  }
  componentWillUnmount() {
    window.removeEventListener("mousemove", this.handleMouseMove);
  }

  render() {
    // 通过render prop把状态传递给外部
    return this.props.render(this.state);
  }
}

// 使用Render Props
const MouseTracker = () => (
  <MousePosition
    render={(mouse) => (
      <div>
        鼠标位置：{mouse.x}, {mouse.y}
      </div>
    )}
  />
);
```

:::
