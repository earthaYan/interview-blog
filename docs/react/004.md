# react 事件机制

## react 的 key 属性

key 是列表里每一个元素的唯一身份证，可以减少不必要的内容更新和 dom 节点的销毁重建，帮助 React 进行高效的 diff 和更新。

在 diff 过程中，key 属性可以：

- 精确识别元素是否是新增/删除/移动的
- 最大限度复用现有节点，而不是销毁重建

选取原则：

1. 唯一性：不重复
2. 稳定性：必须保持不变
3. 可关联性：应该与列表中的数据项相关联，比如使用数据中自带的 ID

> 避免使用 index 作为 key

react 的 key 还可以用于强制销毁旧组件实例，创建新实例。意味着内部所有状态都会被重置
`<UserProfile id={current.id} key={current.id}/>`

## react 的合成事件机制

React17 以前，事件委托是将监听器放在 document 节点上，React17 以后，为了更好的支持微前端架构，将监听器放在了 React 应用的根节点上，避免多个 React 版本共存的情况下事件委托发生冲突。

React 有自己的事件机制，他在原生事件对象上封装了一层，形成了合成事件对象(SyntheticEvent)，抹平了浏览器差异，提供了统一的接口。

1. 用户点击按钮，触发原生 click 事件
2. 原生事件在 DOM 中冒泡，直到 React 根节点监听器捕获该事件
3. React 从事件池中获取一个 SyntheticEvent 对象，并用原生事件的信息进行填充
4. **React 模拟事件冒泡，在组件树中逐级调用对应的事件处理函数**
5. 执行组件上的事件处理函数
6. 执行完毕后，SyntheticEvent 对象被回收至事件池，等待下一次复用

但由于 SyntheticEvent 对象会被回收复用，所以在异步任务中无法访问，需要使用`e.persist()`方法持久化事件对象，或者用一个变量承接当前的事件对象

## 受控/非受控组件

区分标准：表单的数据由谁来管理

- 受控组件：表单数据由 react state 控制
- 非受控组件：表单数据由 DOM 自身管理，React 仅在需要时通过 ref 从 DOM 读取数据

### 受控组件

工作流程：

1. 组件 state 存储当前表单的值
2. state 值通过 value prop 传给表单元素 input 等
3. 用户交互触发 onChange 事件
4. onChange 事件处理器更新组件的 state
5. state 更新导致组件重新渲染，表单显示新值

使用场景：

1. 需要实时验证或格式化用户输入
2. 多个表单字段之间存在依赖关系
3. 需要根据输入框的值，动态改变另一个 ui 元素

### 非受控组件

工作流程：

1. 使用 useRef 创建一个引用
2. 通过 ref prop 将其添加到 dom 元素(如 input)上
3. 使用 defaultValue 设置初始值，而不是 value
4. 需要时通过 ref.current.value 读取值

适用场景：

1. 搜索框，一次性命令操作
2. 文件输入，上传组件

### 选择

1. 绝大多数情况下首选受控组件，更符合 react 声明式编程的理念
2. 简单场景使用非受控组件，涉及文件上传则直接使用非受控模式

## react 中的组合模式

1. 内容组合，props.children
2. 组件特化，通过传入组件作为不同的 props 实现，比如 Dialog 组件传入 title，content 等 props
3. 逻辑组合，通过自定义 hook 实现

## react 严格模式

只在**开发模式**下启用额外的检查和警告，识别不安全实践。通过`<React.StrictMode>`包裹组件开启严格模式
