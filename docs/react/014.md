# react 服务端渲染-nextjs(1)

即便项目文件存在你的电脑里，但当浏览器访问页面时：

- 浏览器不会直接读取硬盘的 .js / .jsx / .tsx 文件
- 浏览器只能从 HTTP 请求返回的 bundle 中获取 JS

hydration：浏览器在接收到服务端渲染内容（HTML 或 RSC Payload）后，将静态内容变成可交互的 React 组件的过程

## Server 和 Client Components

Next.js 会把组件拆成 Server 组件和 Client 组件，并分别构建两套模块图。

服务端在 Server 组件执行完成后，生成 React Server Component(RSC) payload 发送给客户端，这是一种类 JSON 的结构化流式数据，包括：

- Server 组件 的执行结果(生成类 json 的描述)
- Client 组件 渲染占位符和引用的 js 文件

客户端(浏览器)收到后，React Runtime 解析 RSC 数据并重建组件树(虚拟 DOM 树)。遇到 Client 组件渲染占位符时，会按需加载相应的客户端 JS，并对这些 Client 组件执行 hydration。Server 组件不会在客户端执行。

## 项目目录结构

- 文件夹名称用`()`包裹,则这个文件夹名称不会出现在 url 的路径上
- 文件夹名称用`[]`包裹，则这层是一个动态路由

> 动态路由 `/dashboard/invoice/${id}/edit`

- app 文件夹：项目的主目录

  - page.js:应用的 main page,页面入口,文件名必须固定
  - layout.js:创建跨多个页面共享的 UI
  - error.jsx:出错展示页
  - loading.js: 基于 React Suspense 的特殊文件,页面内容加载中的时候作为
    fallback ui 展示
  - /ui 文件夹：所有 UI 组件
    - global.css：可以在 layout.js 中引入，在该文件中引入 tailwindcss
    - fonts.ts：字体文件

- next.config.js:next 配置文件
- public 文件夹：存放静态资源

::: code-group

```js [app/page.js]
import LikeButton from "./like-button";

function Header({ title }) {
  return <h1>{title ? title : "Default title"}</h1>;
}

const HomePage = () => {
  return (
    <div>
      <Header title="Develop. Preview. Ship." />
      <LikeButton />
    </div>
  );
};

export default HomePage;
```

```js [app/layout.js]
const RootLayout = ({ children }) => {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
};
export default RootLayout;
```

```js [app/like-button.js]
"use client";

import { useState } from "react";

export default function LikeButton() {
  const [likes, setLikes] = useState(0);

  const handleClick = () => {
    setLikes(likes + 1);
  };

  return <button onClick={handleClick}>Like ({likes})</button>;
}
```

:::

## 字体和图片优化

### 字体优化

对于字体而言，布局偏移(CLS)是指浏览器最初使用备用字体或系统字体渲染文本，然后在自定义字体加载完成后将其替换为自定义字体,这种替换会导致文本大小、间距或布局发生变化，进而影响周围元素的移动,所以需要进行优化
::: code-group

```js [font.ts]
//保存所有用到的字体文件
import { Inter } from "next/font/google";

export const inter = Inter({ subsets: ["latin"] });
```

```js [layout.tsx]
import "@/app/ui/global.css";
import { inter } from "@/app/ui/fonts";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode,
}) {
  return (
    <html lang="en">
      <body className={`${inter.className} antialiased`}>{children}</body>
    </html>
  );
}
```

:::

### 图片优化

```jsx
import Image from "next/image";
//Next.js 会根据 width/height 比例自动计算高度：
<Image
  src="/hero-desktop.png"
  width={1000}
  height={500}
  className="hidden md:block"
  alt="Screenshots of the dashboard project showing desktop version"
/>;
```

## 路由系统

![路由映射](./imgs/routing-solution.avif)

### app route 和 page route 区别

- Pages Router：页面默认 Client Component，浏览器接收 HTML 后整页 hydration
- App Router：页面默认 Server Component，浏览器只对 Client Component 的部分做 hydration

| 特性           | Pages Router             | App Router                                                |
| -------------- | ------------------------ | --------------------------------------------------------- |
| 默认组件       | Client                   | Server                                                    |
| Hydration 范围 | 整个页面                 | 仅 Client Component                                       |
| HTML 首屏      | SSR/SSG HTML → hydration | RSC Payload → 客户端重建 DOM + Client Component hydration |
| JS 发送量      | 页面大部分 JS 都发送     | Server Component 不发 JS，减少前端 JS                     |

在 Next.js App Router 中，layout.tsx 的 children 就是该布局下对应路由的 page.tsx 导出的组件

## 跳转优化

### Link 组件

使用 `<a>` 进行内部跳转不会触发 React 的局部重渲染，而是触发浏览器的整页刷新，导致整个 React 应用卸载并重新加载。

```js
import Link from "next/link";

<Link key={link.name} href={link.href}>
  <LinkIcon className="w-6" />
  <p className="hidden md:block">{link.name}</p>
</Link>;
```

### usePathName

作用：获取当前 url 的路径

```jsx
import { usePathname } from "next/navigation";

function NavLinks() {
  const pathname = usePathname();
  return (
    <>
      <Link
        key={link.name}
        href={link.href}
        className={clsx({
          "bg-sky-100 text-blue-600": pathname === link.href,
        })}
      >
        link
      </Link>
    </>
  );
}
```

## 异步组件

如果我们需要在 server component 中获取数据，就必须使用异步组件,方便内部使用 await 获取数据

```js
const Page = async () => {};
```

## 静态渲染 vs 动态渲染

静态渲染：服务端的异步数据获取和渲染只会发生在构建部署或者 html 过期需要重新生成(revalidate)，相当于用户访问的是缓存在服务端或者 CDN 的 html 文档,同时有利于 SEO

动态渲染:当用户访问的时候,服务端才会进行数据获取和内容渲染,可能会出现白屏现象

## streaming 流式传输

streaming 数据传输技术可以把一个路由分解为更小形式的"chunk",当某个 chunk 准备好后将其从服务端发送到客户端,客户端收到 chunk 后 立即渲染对应部分,这样可以避免长时间的数据请求阻塞页面渲染,每个 React 组件都可以看作是一个 chunk

![流式传输](./imgs/server-rendering-with-streaming-chart.avif)

- 页面级别:loading.tsx
- 组件级别:将异步请求放到对应的子组件内部,然后再在父组件使用 Suspense 包裹该子组件

## hooks

> Next.js 会自动把 URL 中的 search params 作为 props 传入 page 组件

```jsx
import { useSearchParams, useRouter, use yPathname } from "next/navigation";
// 输入搜索关键词修改url查询参数
const searchParams = useSearchParams();
const { replace } = useRouter();
const pathName = usePathname();

const handleSearch = (term: string) => {
  const search = new URLSearchParams(searchParams);
  search.set("page", "1");
  if (term) {
    search.set("query", term);
  } else {
    search.delete("query");
  }
  replace(`${pathName}?${search.toString()}`);
};

<input
  className="peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500"
  placeholder={placeholder}
  onChange={(e) => {
    handleSearch(e.target.value);
  }}
  //根据url设置查询参数
  defaultValue={searchParams.get("query")?.toString()}
/>;
```

## React Server Actions

作用:一方面能在 node 服务器上直接运行异步代码,不需要创建 API 接口来修改数据,只需要写异步函数。而另外一个主要作用是保证应用安全

本质：Server Action 创建了一个 POST API 请求

标记：在文件顶部标注`'use server'`，那这个文件导出的所有函数都默认是 Server Action

调用：只运行在服务端，但 client 和 server component 都可以调用，且不会被打包到客户端的 js bundle

treeshaking:文件中没有被使用的函数会直接被从构建产物中删除，减小打包体积

### 步骤

1. 创建 actions 异步函数，函数内部进行数据库操作
2. 将这个异步函数传递给 form
