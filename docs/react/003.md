# Fiber 架构

React16 前，React 使用 stack reconciler(堆栈调和器)，更新过程是同步且不可中断，在渲染复杂组件树的时候会长时间占用主线程，导致页面卡顿或输入延迟。因为 React 必须“从头到尾”完成整棵组件树的更新才能返回控制权。

而 Fiber reconciler 核心是化整为零。将一个庞大的更新任务拆分成多个工作单元(每个组件对应一个 fiber 节点),React 在完成一个工作单元后，会把控制权还给浏览器，检查是否有更高优先级的任务(响应用户输入等)，浏览器通过事件循环调度这些任务，保证高优先级事件能及时执行。执行完成再从中断处恢复，继续未完成的 fiber 任务。

但问题是渲染任务随时中断恢复会搞乱界面，为此，每个 fiber 有 2 个阶段：

1. 渲染/调和阶段：属于可中断的异步阶段，计算出所有节点变更，构建“工作中的 fiber 树”，这个过程都只停留在内存，不会操作真实的 DOM，可以被打断和恢复，不会产生用户可见的副作用。
2. commit 阶段：将上一步计算出的变更一次性提交到真实 DOM 并执行副作用，这是同步执行的，保证 ui 一致性。

他解决了 3 个问题：

1. 实现了增量渲染，避免主线程被长时间占用导致卡顿
2. 实现了更新的优先级调度，React 给不同更新任务赋予不同优先级，比如最高优先级是用户输入，最低优先级是网络请求返回的数据更新
3. 为 React 后续的并发新特性提供了可能性

解决的根本问题:确保应用在持续进行复杂计算的同时，依然能够保持流畅的交互和视觉响应

---

Q:React Fiber 是什么？为什么要引入 Fiber

A:React16 前用的是 Stack Reconciler，更新是同步且不可中断的。当组件树很复杂时，React 一次渲染会长时间占用主线程，造成页面卡顿或输入延迟。而 Fiber 架构的核心思想是“化整为零”,把一个大的更新任务拆分成多个小的 Fiber 节点，React 每执行完一个节点就可以让出主线程，在有空闲时间或低优先级任务时再继续执行。

---

Q: Fiber 是怎么实现可中断的？

A:Fiber 是链表型树，每个组件对应一个 Fiber 节点，保存了组件类型、状态 props 等信息， 这种结构允许逐个节点遍历，不依赖递归调用栈，所以可以在任意节点暂停和恢复； Fiber 通过将更新拆分为可中断的节点，并结合 Scheduler 进行优先级调度，实现了可中断的渲染；Render 阶段可暂停，Commit 阶段同步更新，保证 UI 一致性。

---

Q:如果随时中断，UI 不会乱吗？

A:不会，React 把更新流程分为两个阶段，Render 阶段就像在纸上算账，可暂停可恢复；Commit 阶段才会把结果一次性写入 DOM，所以界面永远不会出现半成品或混乱状态。

---

Q:Fiber 是不是让 React 渲染更快了？

A:Fiber 提升的是用户感知的响应速度，而不是渲染的绝对执行速度；因为有调度开销，总耗时可能略大于旧架构，但是用户体验上更加平滑，不会卡顿。

## 各种概念

**Fiber**

职责：把组件树拆分成最小可执行单元（unit of work）

理解：Fiber 是“工作清单”，每个节点对应一个组件或 DOM 元素的更新

**Scheduler（调度器）**

职责：决定哪些 Fiber 单元先执行、优先级高低、是否中断

理解：调度器是“决策者”，根据优先级和浏览器空闲时间，选择要处理的 Fiber

**Time Slicing（时间切片）**

职责：按照 Scheduler 的策略，将任务分配到多帧（frame）中执行，保证浏览器主线程不卡顿

理解：时间切片是“执行方式”，把大任务分段渲染，空闲时间先做高优先级任务
