# useImperativeHandle 和 forwardRef

React 设计上是从上到下的单向数据流,父组件通过 props 将数据传入子组件,子组件通过回调函数通知父组件改变状态;但在一些特殊场景下,比如输入框聚焦/滚动元素到指定区域,这些是无法通过上述通信机制完成的,所以需要 ref 让父组件能够直接命令子组件去做某些事情

class 组件天生有实例,父组件可以传 ref 给子组件，因为 React 会把实例挂载到 ref.current,但是函数式组件每次渲染都是重新执行,没有实例概念,所以不能直接给子组件传 ref，需要 forwardRef 打通。

而如果直接把子组件的 ref 暴露给父组件，风险太高，所以需要 useImperativeHandle 自定义暴露的范围

::: code-group

```jsx [class组件]
class MyInput extends React.Component {
  focus() {
    this.input.focus();
  }
  render() {
    return <input ref={(el) => (this.input = el)} />;
  }
}
function Parent() {
  const ref = React.createRef();
  return (
    <>
      <MyInput ref={ref} />
      <button onClick={() => ref.current.focus()}>Focus</button>
    </>
  );
}
```

```jsx [函数组件]
import React, { useRef, forwardRef, useImperativeHandle } from "react";

// 子组件：暴露 focus 方法给父组件
const MyInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  // 自定义暴露给父组件的接口
  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    clear: () => (inputRef.current.value = ""),
  }));

  return <input ref={inputRef} placeholder="Type here..." />;
});

// 父组件：使用子组件的 ref
function App() {
  const inputRef = useRef(); // 获取子组件接口

  return (
    <div>
      <MyInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>聚焦输入框</button>
      <button onClick={() => inputRef.current.clear()}>清空输入框</button>
    </div>
  );
}

export default App;
```

:::
