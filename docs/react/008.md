# useCallback 和 useMemo

react 的性能问题来源于 React 不必要的重渲染,而且会带着内部的子组件一起重渲染.

React.memo 可以缓存组件,理论上如果 prop 不变的话,该组件就不会被重渲染,但实际上父组件如果重渲染,会导致父组件函数重新执行,内部的变量/方法都会重新创建,即使内容相同,但引用地址已经发生变化,所以对子组件来说.props 就是发生了变化,子组件还是会进行不必要的重渲染.

这时候就需要使用 useMemo 和 useCallback 了.useMemo 用于缓存计算结果,useCallback 用于缓存函数本身,这样只有依赖发生变化,他们的引用才会发生变化,避免了不必要的重渲染

## 滥用的坏处

1. 缓存是存储在内存里的,滥用会导致内存开销增加
2. 初始渲染会变慢:需要比较依赖项数组,执行 hook 自身逻辑,这些开销可能比直接执行还要大
3. 太多的 useXXX 导致代码可读性变差,依赖项数组管理可能会出现遗漏,增加心智负担
4. 容器出现依赖项陷阱,比如 useCallback 的依赖项有误,

## 使用场景

### useMemo:

1. 和 React.memo 配合使用传递对象 prop
2. 大数据量操作

### useCallback:

1. 和 React.memo 配合使用传递函数 prop
2. 函数作为其他 Hooks 的依赖项

## 决策流程

1. 让代码正常工作
2. 使用 react devTool 中的 profiler 分析,找到真正的性能瓶颈
3. 针对性优化
4. 确认优化是否真的达到预期目标
