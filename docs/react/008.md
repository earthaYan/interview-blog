---
outline: deep
---

# useCallback 和 useMemo

react 的性能问题来源于 React 不必要的重渲染,而且会带着内部的子组件一起重渲染.

React.memo 可以缓存组件,理论上如果 prop 不变的话,该组件就不会被更新,但实际上父组件如果重渲染,会导致父组件函数重新执行,内部的变量/方法都会重新创建,即使内容相同,但引用地址已经发生变化,所以对子组件来说，props 还是发生了变化,子组件还是会进行不必要的重渲染.

这时候就需要使用 useMemo 和 useCallback 了.useMemo 用于缓存计算结果,useCallback 用于缓存函数本身,这样只有依赖发生变化,他们的引用才会发生变化,避免了不必要的重渲染

## 滥用的坏处

1. 缓存是存储在内存里的,滥用会导致内存开销增加
2. 初始渲染会变慢:需要比较依赖项数组,执行 hook 自身逻辑,这些开销可能比直接执行还要大
3. 太多的 useXXX 导致代码可读性变差,依赖项数组管理可能会出现遗漏,增加心智负担
4. 容器出现依赖项陷阱,比如 useCallback 的依赖项有误,

## 使用场景

### useMemo:

1. 和 React.memo 配合使用传递对象 prop
2. 大数据量操作

### useCallback:

1. 和 React.memo 配合使用传递函数 prop
2. 函数作为其他 Hooks 的依赖项

## useState

useState 的 state 不是存在组件函数里，而是存在 Fiber 节点的 Hook 链表中。
每次调用 useState ，React 都会创建一个 Hook 节点，并把当前 state 存在 `hook.memoizedState`。组件重新渲染时，React 不会重新创建 state，而是沿着 Fiber 上的 Hook 链表顺序取回之前保存的 state。setState 会把更新放到 `hook.queue` 中，在下一次 render 时再根据队列计算新的 state。
