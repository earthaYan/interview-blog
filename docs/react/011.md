# React18 hooks

## useId

我们日常开发中经常需要给组件或 DOM 元素设置唯一 ID，比如表单里有一个输入框，可能有验证错误，需要给错误信息设置 aria-describedby，让屏幕阅读器能读到

### 传统方法

1. 手动维护每个组件的 id，从组件外部传入
2. 使用 Math.random
3. 使用第三方库

前者会让开发者心智负担增加，如果在同一页面渲染多个组件，手动写 ID 容易重复，还会破坏组件封装性。而后者在 SSR 场景下服务端和客户端生成的 id 会不一致，导致服务端和客户端水合失败，而 useId 的出现解决了这些问题

### 使用:

在函数组件顶层调用 useId,生成稳定唯一的 id

### 原理

useId 会根据 React 在 SSR 和客户端渲染时对组件树的一致遍历顺序来生成稳定的递增 ID。因此 SSR 得到的 ID 和 hydration 客户端生成的 ID 保持一致，不会导致 hydration mismatch。

### 最佳实践

1. 必须在函数组件顶层调用
2. 多 ID 场景下，推荐只在组件顶层调用一次，将其作为 baseId 前缀，后缀使用语义化明显的字符串进行拼接
3. 不用将其当作列表的 key

## 并发渲染特性-useTransition

> 无论是防抖还是节流，本质上都是控制函数执行频率，解决的是事件触发过于频繁导致性能问题,和渲染无关，而 React18 的并发特性是控制渲染优先级，优化 UI 响应感

作用：主动告知 React 非紧急更新

场景：模糊搜索框，双状态

1. 可以直接控制状态更新逻辑
2. 需要明确展示 loading 的

```jsx
import React, { useState, useDeferredValue } from "react";

// 假设有一个超大的列表
const largeList = Array.from({ length: 10000 }, (_, i) => `Item ${i + 1}`);

export default function DeferredSearch() {
  const [query, setQuery] = useState("");

  // useDeferredValue 会延迟更新 deferredQuery
  const deferredQuery = useDeferredValue(query);

  // 过滤列表：使用 deferredQuery 而不是 query
  const filteredList = largeList.filter((item) =>
    item.toLowerCase().includes(deferredQuery.toLowerCase())
  );

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="搜索..."
      />
      <div style={{ maxHeight: "300px", overflowY: "auto" }}>
        {filteredList.map((item) => (
          <div key={item}>{item}</div>
        ))}
      </div>
    </div>
  );
}
```

> useTransition 的优势体现在 “双状态模式（输入值 + 派生数据）”

## 并发渲染特性-useDeferredValue

低优先级渲染某个值，但不会有 isPending 状态，单状态

场景：

```jsx
function DeferredSearch() {
  const [query, setQuery] = useState("");
  // useDeferredValue 会延迟更新 deferredQuery
  const deferredQuery = useDeferredValue(query);

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="搜索..."
      />
      <div style={{ maxHeight: "300px", overflowY: "auto" }}>
        {filteredList.map((item) => (
          <div key={item}>{item}</div>
        ))}
      </div>
    </div>
  );
}
```

## 并发特性总结

价值：不是让渲染更快，而是让响应更快

关键特性：

1. 时间切片：将渲染任务分割成小块
2. 优先级调度：重要任务优先处理
3. 非阻塞：高优先级任务可以中断低优先级任务

核心能力：

1. 可以区分优先级
2. 可以中断渲染：高优先级任务可随时插队
3. 即时反馈：让用户始终感知到响应

> React18 默认只在 createRoot + 有触发条件时 才启用并发调度。
