---
outline: deep
---

# React 18 Hooks

## useId

在开发中，我们常常需要为组件或 DOM 元素设置唯一 ID，例如表单中的输入框需要有一个 `aria-describedby` 来让屏幕阅读器读到错误信息。

### 传统方法

1. 手动维护每个组件的 ID，从外部传入。
2. 使用 `Math.random()`。

手动维护 ID 容易重复冲突;另外`Math.random()`在 SSR 场景下会遇到问题，服务端和客户端生成的 ID 不一致，会导致水合失败。而`useId` 解决了这些问题。

### 原理

`useId`不依赖随机数，而是根据组件在组件树中的位置(层级 + 调用顺序)生成唯一 ID

### 最佳实践

1. 在函数组件顶层调用 `useId`，生成稳定唯一的 ID。
2. 在多个 ID 场景下，推荐在组件顶层调用一次，将其作为 `baseId` 前缀，后缀使用语义化明显的字符串进行拼接,减少性能开销保持关联性
3. 不要将其作为列表的 `key`,`key`需绑定数据唯一性,`useId`绑定组件位置，列表数据顺序变化会导致 React 误判为增删，触发 DOM 全量重建

## 并发渲染

无论是防抖/节流，本质上还是控制函数执行频率，解决的是事件触发过于频繁导致的性能问题，和渲染逻辑无关。并发渲染特性则是通过控制渲染优先级，解决高耗时渲染阻塞主线程的问题，让 UI 始终响应。

### `useTransition`

核心作用:主动标记某个状态更新(即 setState)为低优先级，确保高优先级任务(如用户交互)保持高响应性，同时可通过 isPending 感知更新状态，提供加载反馈

场景:

1. 搜索框实时过滤长列表（如 1w+ 数据的模糊匹配）
2. 大数据渲染（如表格渲染 2w+ 行数据）
3. 跳转页面前的轻量 loading（如提交表单后等待接口响应的过渡态）
4. 表单提交/筛选后的复杂视图更新（如筛选后渲染图表、嵌套列表）

```jsx
// [优化长列表过滤]
import { useState, useTransition } from "react";
export default function SearchList() {
  const [text, setText] = useState("");
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition({
    //等待高优先级完成的最长时间
    timeoutMs: 2000,
  });
  const handleChange = (e) => {
    const value = e.target.value;
    // 1. 高优先级更新：输入框值实时响应，不阻塞用户输入
    setText(value);
    // 2. 低优先级更新：标记为低优先级，不阻塞主线程
    startTransition(() => {
      // 高耗时计算：即使耗时久，也不会卡住输入框
      const filteredList = Array.from(
        { length: 20000 },
        (_, i) => `${value}-${i}`
      );
      setList(filteredList);
    });
  };

  return (
    <div className="search-container">
      <input
        value={text}
        onChange={handleChange}
        placeholder="输入关键词过滤"
        disabled={false}
      />
      {/* 加载反馈：过渡态未完成时显示 */}
      {isPending && <div className="loading">正在过滤...</div>}
      <ul className="list">
        {list.map((item, i) => (
          <li key={i}>{item}</li> // 注：生产环境优先用数据唯一 ID 做 key
        ))}
      </ul>
    </div>
  );
}
```

核心优势在于双状态分离，可以将 “用户输入的原始值（高优先级）” 与 “派生的渲染数据（低优先级）”分离，确保用户交互（输入、点击）始终流畅，高耗时计算延迟执行且不阻塞主线程。

### `useDeferredValue`

核心作用：创建一个延迟版本的状态值，高优先级任务（如输入）执行时，延迟值暂时保留旧值，等主线程空闲后再同步为新值，避免非关键 UI 阻塞用户交互,需要用户自行处理 pending

场景：

1. 模糊搜索下拉列表（输入时先显示旧列表，空闲后更新新列表）
2. 实时预览（如富文本编辑器，输入时先保留旧预览，空闲后更新）
3. 非核心数据的实时更新(如排行榜、非关键统计数据)

```jsx
import { useState, useDeferredValue, memo } from "react";

// 子组件：memo 避免无意义重渲染
const FilteredList = memo(({ list, query }) => {
  return (
    <ul>
      {list
        .filter((item) => item.includes(query))
        .map((item, i) => (
          <li key={i}>{item}</li> // 生产环境替换为数据唯一 ID
        ))}
    </ul>
  );
});

export default function Search({ list }) {
  const [query, setQuery] = useState("");
  // 创建延迟版本的 query：输入时暂时保留旧值，主线程空闲后更新
  const deferredQuery = useDeferredValue(query, {
    timeoutMs: 1000, // 可选：超时强制同步
  });

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="输入搜索关键词"
      />
      {/* 基于延迟值渲染：避免输入时阻塞列表更新 */}
      <FilteredList list={list} query={deferredQuery} />
    </div>
  );
}
```

### 区别

二者核心区别在于主动和被动。

1. 需要主动控制「某个 setState 为低优先级」+ 要显示 loading 反馈 → 用 useTransition
2. 只需要「某个状态延迟更新」，不需要主动触发和 loading → 用 useDeferredValue

## 并发特性总结

核心价值：不是让**渲染**更快，而是让**UI 响应**更快，高耗时渲染不会阻塞主线程

### 关键能力：

1. 时间切片（Time Slicing）：将长渲染任务拆分为多个小任务，分散到浏览器的空闲时段执行，避免长时间阻塞主线程；
2. 优先级调度：React 内置任务优先级（如输入 > 过渡态更新 > 懒加载），高优先级任务可 “插队” 执行；
3. 非阻塞渲染：低优先级渲染可被高优先级任务中断，完成高优先级任务后再恢复低优先级渲染，确保交互无卡顿。

### 启用条件

1. 根节点通过 ReactDOM.createRoot() 创建
2. 使用 useTransition/useDeferredValue/Suspense 等并发特性触发
