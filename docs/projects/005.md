# DTLE 项目(三)：项目亮点

## 非侵入式替换

当时项目已经完成，客户因为信创需求，需要替换文案和 logo，同时产品还要保持通用性。我采用了‘构建期条件编译 + 运行时 DOM 观察’方案：

构建期只在客户包里引入替换脚本，运行时用 MutationObserver 监听 DOM 变化，捕获到目标节点后原地修改文本或替换节点。

我也考虑过全局替换或 Provider + 后端配置方案，但全局替换会破坏通用性，Provider 方案虽然合理，但项目已完成且后端无法及时支持，所以快速响应下选择了 Observer。

为避免性能问题，我只监听 body 的新增节点，且仅在包含目标内容时替换，而且原地修改 textContent，不会引发大面积重排。”
最终我采用了 “构建期条件编译 + 运行时 DOM 观察（MutationObserver）” 方案

1. 通过条件编译只在构建指定客户的包的时候引入替换脚本
2. 运行时通过 MutationObserver 监听 DOM 变化，捕获到对应内容时执行替换脚本的回调函数

### 追问 1：有没有想过其他方案呢

首先想到的是全局替换，但这种方法不能保证产品通用性，且直接无脑替换会引发其他问题，所以直接放弃这个房外，其次当时有想过封装一个 Provider，让后端提供一个接口用于获取配置。

新项目从 0 设计的话，用 Provider + 后端配置是非常合理；但现实情况是项目开发已经完成，客户因为政策原因临时提出这个修改，但历史代码散落在各处，要一处处去改，成本太高，不太符合快速响应的诉求，而且后端人力资源当时也无法分配。当然如果现在有一个新启动的项目出现这种需求，我会优先选择这个方案。

### 追问 2：会不会性能方面的问题

确定，监听 DOM 变化替换 DOM 节点本质上开销还是蛮大的，所以在实现的时候做了一些处理：

1. 2. 文本替换本身是原地修改 textContent，不插入/删除节点，不会引起大面积重排
2. 只监听 body 的 childList，而且只处理新增节点里的 Text 节点，并且只在包含目标字符串时才做替换，大部分 DOM 变化其实 observer 什么都不干

## 长列表虚拟滚动

在 dtle 项目里，有一个迁移对象选择，左侧是源库对象，整体是一个树形结构，用户勾选需要迁移的数据库和表，右侧是一个表格，用于对左侧已选择的对象进行列配置和数据过滤，源库对象信息是从接口一次性全量返回的列表。

当接口返回的全量数据量超出一定量的时候，滚动开始出现卡顿。原因是当源库对象较多的时候，上万个 DOM 节点同时渲染，严重占用内存。而虚拟列表的核心就是只在当前可视范围内渲染 1-2 屏，减少不必要的 DOM 创建，同时保证滚动体验连续且无白屏

实现：
::: code-group

```tsx [定高]
import { useState, useRef } from "react";

const TodoList = ({ data, itemHeight = 50, height = 300, overscan = 5 }) => {
  const containerRef = useRef(null);
  const [scrollTop, setScrollTop] = useState(0);
  // 可视区域渲染条数
  const visibleCount = Math.ceil(height / itemHeight);
  //处理滚动事件
  const onScroll = (e: any) => {
    setScrollTop(e.currentTarget.scrollTop);
  };
  //确定渲染数据
  const startIndex = Math.max(Math.floor(scrollTop / itemHeight) - overscan, 0);
  const endIndex = Math.min(
    startIndex + visibleCount + 2 * overscan,
    data.length
  );
  // 渲染窗口内的数据
  const visibleData = data.slice(startIndex, endIndex);
  //上下占位高度
  const paddingTop = startIndex * itemHeight;
  const paddingBottom = (data.length - endIndex) * itemHeight;

  return (
    <>
      <div
        ref={containerRef}
        onScroll={onScroll}
        style={{
          height: `${height}px`,
          overflowY: "auto",
          border: "1px solid #ccc",
        }}
      >
        <div style={{ paddingTop: paddingTop, paddingBottom: paddingBottom }}>
          {visibleData.map((item: any, index: number) => (
            <div
              key={startIndex + index}
              style={{
                height: `${itemHeight}px`,
                display: "flex",
                alignItems: "center",
                padding: "0 10px",
                borderBottom: "1px solid #eee",
                boxSizing: "border-box",
              }}
            >
              {item}
            </div>
          ))}
        </div>
      </div>
    </>
  );
};
export default TodoList;
```

```tsx [不定高]
import React, { useRef, useState, useEffect, useCallback } from "react";

interface Item {
  id: number;
  text: string;
}

interface VariableHeightVirtualListProps {
  items: Item[];
  containerHeight: number; // 容器高度
  overscan?: number; // 超渲染行数
}

export const VariableHeightVirtualList: React.FC<
  VariableHeightVirtualListProps
> = ({ items, containerHeight, overscan = 3 }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [scrollTop, setScrollTop] = useState(0);

  // 保存每行高度和累积偏移
  const [rowHeights, setRowHeights] = useState<number[]>([]);
  const [rowTops, setRowTops] = useState<number[]>([]);

  const rowRefs = useRef<Map<number, HTMLDivElement>>(new Map());

  // 滚动事件
  const onScroll = (e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  };

  // 测量行高
  useEffect(() => {
    const observer = new ResizeObserver(() => {
      const heights = items.map(
        (_, index) => rowRefs.current.get(index)?.offsetHeight || 0
      );
      const tops: number[] = [];
      let total = 0;
      for (let h of heights) {
        tops.push(total);
        total += h;
      }
      setRowHeights(heights);
      setRowTops(tops);
    });

    rowRefs.current.forEach((el) => el && observer.observe(el));
    return () => observer.disconnect();
  }, [items]);

  // 二分查找当前可视起始索引
  const findStartIndex = useCallback(() => {
    let left = 0;
    let right = rowTops.length - 1;
    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      if (rowTops[mid] < scrollTop) left = mid + 1;
      else right = mid;
    }
    return left;
  }, [rowTops, scrollTop]);

  const startIndex = findStartIndex();
  // 计算结束索引
  let endIndex = startIndex;
  let visibleHeight = 0;
  while (endIndex < items.length && visibleHeight < containerHeight) {
    visibleHeight += rowHeights[endIndex] || 0;
    endIndex++;
  }
  // 加上 overscan
  const renderStart = Math.max(0, startIndex - overscan);
  const renderEnd = Math.min(items.length, endIndex + overscan);

  const paddingTop = rowTops[renderStart] || 0;
  const paddingBottom =
    (rowTops[rowTops.length] ||
      rowTops[rowTops.length - 1] + (rowHeights[rowHeights.length - 1] || 0)) -
    (rowTops[renderEnd] || 0);

  return (
    <div
      ref={containerRef}
      onScroll={onScroll}
      style={{
        height: containerHeight,
        overflowY: "auto",
        border: "1px solid #ccc",
      }}
    >
      <div style={{ paddingTop, paddingBottom, position: "relative" }}>
        {items.slice(renderStart, renderEnd).map((item, idx) => {
          const index = renderStart + idx;
          return (
            <div
              key={item.id}
              ref={(el) => el && rowRefs.current.set(index, el)}
              style={{
                boxSizing: "border-box",
                borderBottom: "1px solid #eee",
                padding: "8px",
                background: index % 2 === 0 ? "#fafafa" : "#fff",
              }}
            >
              {item.text}
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

:::

### 追问：这个方案需要关注哪几个维度

1. **可视区域高度（viewport height）**:虚拟列表基于「可视窗口」计算渲染范围，所以容器高度是计算渲染窗口的基础参数。如果容器高度不准确，就会出现空白或重叠问题。
2. **item 高度（item height）**:如果是固定高度列表，计算可见项数量直接用除法即可；如果是动态高度列表中（如内容不同长度的日志），就需要通过 ResizeObserver 实时测量

3. **总高度**:item count × item height
4. **over scan(预渲染区间)**：有时候滚动过快，容易出现白屏，所以一般会预加载 1-2 屏
5. **scrollTop(滚动偏移)**：在 scroll 事件中计算 startIndex 和 endIndex，确定渲染内容

### 追问：overscan 你是怎么确定的呢

因为当用户滚动到临界区域时，如果只渲染视口内的数据，新的内容可能还没来得及生成，就会出现短暂的空白。借助 overscan，可以提前把即将出现的内容放进 DOM，但这个数值需要做一下权衡，如果过小，滚动可能闪烁，太大就会同时渲染太多节点，会增加内存占用和 diff 成本。

所以通常会结合列表滚动速度动态调整 overscan 值，比如静止或缓慢滚动时只多渲染 5 条，快速滚动时会扩充到 10 ～ 15 条。这样既保证了性能，又保持了流畅度。

### 追问：是否有想过其他方案

一开始有想过用一个普通的 div 加 overflow: auto 再配合懒加载，暂时解决这个问题；但这个方案被否了，原因是数据稍微多一点还是会大量创建 DOM 节点，渲染依然会卡，如果后续数据越来越大，这个方案就是在埋雷，而这块内容属于核心页面，体验卡顿会非常影响用户体验，所以还是得从渲染上解决问题。

在落地的时候也有考虑过 react-window 插件，他的优势是轻量级，但当时生态和文档不如 react-virtualized 完善，如果是纯展示列表，我可能会优先选择这个插件，但我们的需求并不是纯展示列表，所以在当下那个时间点我选择了 react-virtualized。
