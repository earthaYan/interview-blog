<!-- # 性能优化

总体思路先抛一句

这个项目从 2021 年开始做，我当时是从三个方向做性能优化的：打包体积 / 运行时渲染 / 接口和交互层面的“感知性能”。
下面我说几个在代码里真正落地的点。

1. 运行时渲染层：长列表 & 复杂结构的优化
   1）迁移对象选择面板的虚拟滚动（MigrateObjectsRefactor）

你可以点名说这个组件，因为代码里确实有：

使用 react-virtualized 的 <AutoSizer /> + <List />

对 schema / table 选择区域做虚拟列表渲染

做了什么：

把“库 / 表”的树形结构扁平化成 computeShowList，只维护一个线性数组

用 <AutoSizer> 自适应右侧容器宽高

用 <List> 控制只渲染可视区那几十行，非可见行只留空白高度占位

用 rowRenderer 区分库行 / 表行，两种行渲染不同 UI（复选框、输入框、提示文案等）

效果：

有大量库和表时，右侧面板如果一次性全部渲染，DOM 数量会上千，滚动和勾选都会明显卡顿；
虚拟滚动之后，真实渲染的 DOM 控制在几十个以内，滚动和交互都变成接近 60fps。

2）用 useMemo / useCallback 缓存衍生数据 & 回调

在迁移对象组件里，你有类似：

useMemo 把扁平化后的列表缓存起来（比如 computeShowList 这种）

一些事件处理函数也包在 useCallback 里，避免因为父组件重渲染导致子组件函数引用变化

你可以这样说：

对于依赖 schema 表结构生成的衍生列表，我用 useMemo 做了缓存，只有依赖项变了才重新计算，这样可以减少很多无意义的计算和子组件重渲染。

2. 打包 & 体积方面的优化
   1）Ant Design 按需加载 + Less

项目里通过 craco / babel 配置了 antd 的按需加载：

用 babel-plugin-import 按需引入组件和样式

通过 Less 覆盖样式，而不是全量引入 CSS

你可以这么说：

UI 库用的是 Ant Design，我在构建层面做了按需加载配置，只打包实际用到的组件和对应样式，避免把整套 antd 全量打进 bundle，减小首屏资源体积。

2）生产环境构建优化

因为项目是基于 CRA / craco：

生产环境应用 treeshaking、压缩、去掉 dev 代码

SourceMap 只在需要排查问题的环境开启，其余环境关闭，减小响应体积

可以一句话带过：

线上环境都是用 production 模式构建，开启 tree-shaking 和代码压缩；针对 SourceMap 也做了区分环境配置，防止线上多传无用调试信息。

3. 网络和数据层面的优化
   1）列表分页 & 条件查询

像任务列表、节点列表这种：

不是一次性把所有记录拉到前端，而是带分页参数请求

支持按条件筛选（根据任务状态 / 名称 / 时间范围），减小单次数据量

你可以这样表述：

列表数据我都做了接口层分页和筛选，不会把所有任务一次性拉到前端。前端只是渲染当前页的数据，后端负责筛选和分页，这样既减小了传输数据量，也降低了前端渲染压力。

2）避免重复请求 & 复用状态

通过 Redux：

用户、权限等全局数据只在登录 / 刷新时请求一次，放到 store 和 localStorage 里复用

某些基础配置也通过全局 state 复用，避免每个页面各自拉

一句话：

全局性的东西（比如用户信息、权限）放在 Redux + localStorage，用一套初始化逻辑获取，后面页面就直接用，不会每次切换页面都重新调接口。

4. 交互和“感知性能”的优化
   1）品牌替换的性能控制（MutationObserver 也算性能优化范畴）

虽然它主要是品牌需求，但你可以把“怎么避免它拖慢性能”当成一块性能优化来讲：

只监听 body 的 childList，不监听 attributes / characterData

只处理 Text 节点，并且只处理包含 dtle 的文本

替换后打标记避免重复处理

对高频场景用 requestAnimationFrame 做批处理

你可以说：

品牌替换这块我用 MutationObserver 做 DOM 层的兜底替换时也考虑了性能，只监听新增节点、只处理 TextNode、只在命中目标字符串时才操作，并且用 requestAnimationFrame 做了简单节流，避免对主线程造成明显干扰。

2）一些表单和交互避免不必要的重渲染

比如：

把复杂的子块拆成独立组件（例如迁移对象块 / 任务配置块），用 props 驱动，减少整页刷新

控制依赖项避免 useEffect / useMemo 频繁触发

可以抽象地说：

在一些复杂表单和配置向导里，我刻意控制了组件拆分粒度和依赖项，尽量让“真正变化的部分”重渲染，而不是整页一起刷新，这个在任务配置、迁移对象选择等页面里都有体现。

5. 你可以在面试里直接用的一段总结

这个项目从 2021 年开始做，我在性能优化上主要做了三层：

第一，在渲染层面，对像迁移对象选择这种长列表、复杂结构的区域，用 react-virtualized 做了虚拟滚动，先把 Schema/Table 结构扁平化，再通过 AutoSizer + List + rowRenderer 只渲染可视区几十行，避免一次性渲染几百上千个 DOM。

第二，在构建层面，对 Ant Design 做了按需加载配置，结合 production 模式构建和 Less 主题定制，减少首屏 bundle 体积。

第三，在数据和交互层面，所有列表都通过接口分页和筛选拿数据，全局数据通过 Redux 复用，品牌替换的 MutationObserver 也做了严格的监听范围和节流控制，保证不会引入新的性能问题。

总体思路是：重渲染尽量少做、一次渲染尽量少 DOM、打包尽量只带必要代码。

---

先表态：不是“已经完美”，而是“还有空间，但我有方向”

这个项目从 2021 年到现在跑得比较稳定，现有的优化可以满足日常使用，但如果从“高级前端”的视角来看，其实还有不少可以继续打磨的点。
我大概会从三个方向继续优化：打包体积、运行时渲染、网络与数据层。

然后展开。

1️⃣ 打包侧还能做的优化
（1）更细粒度的路由级代码分割（Code Splitting）

现在项目是多页结构（迁移 / 同步 / 订阅 / 用户 / 权限 / 节点管理），其实可以做得更激进一点：

针对不常访问的模块（比如权限管理、账号设置）用 React.lazy + Suspense 做懒加载

把一些“大块业务组件”（比如迁移对象配置、复杂表单向导）拆成独立 chunk，只在需要时加载

你可以这样说：

现在的按需加载主要是针对 AntD 组件层面的，未来可以在业务层进一步细化 code splitting，把不常用的模块拆成独立 chunk，首屏 bundle 再压一截。

(2) 做一次系统性的 bundle 分析 & 拆 vendor

比如用：

webpack-bundle-analyzer 看看：

有没有重复引入的依赖

有没有可以按需拆的第三方库

把“变化少”的大依赖（如图表、某些重库）拆到单独 vendor chunk，挂 CDN + 做长期缓存

简单说，就是“看一眼现在体积到底花在了哪里”，有针对性地减肥。

2️⃣ 运行时渲染层还能继续优化的点
（1）把虚拟滚动从“局部”推广到“更多场景”

你现在已经对 迁移对象选择面板（MigrateObjectsRefactor） 做了虚拟滚动，这是最核心、负载最高的一个点。
后面可以考虑：

对其他可能出现大列表的场景（例如任务列表、预检结果列表）评估：

当数据量足够大时，是否也可以用 windowing 技术优化

或者在同一套虚拟列表抽象上，封装一个内部通用的 VirtualList 组件，避免重复造轮子

你可以说：

目前虚拟滚动主要用在迁移对象选择区域，未来可以用统一的 VirtualList 抽象，把相似场景统一到这套能力上，既提升性能，又减少重复实现。

（2）更系统性地控制重渲染

虽然你现在已经用了一些 useMemo / useCallback，但从经验来看，一个 2021 起步的项目里，肯定还有这些可以继续打磨：

对一些“频繁 render 的复杂组件”（比如行组件、表单子块）加 React.memo，确保 props 不变时完全不重渲染

审查：

inline arrow function

inline object literal
这些地方会让子组件频繁拿到新引用 → 导致不必要更新

你可以很实在地说：

这一块属于“精细化优化”，不是上线必须，但如果要从 90 分打磨到 95 分，可以对关键页面做一次 profiler，把高频重渲染的组件找出来做针对性 memo。

（3）升级到 React 18 / 并发特性（如果项目还没做）

如果你现在还是 React 17：

未来可以考虑逐步升级到 React 18，利用 concurrent rendering、useTransition 等能力，优化一些交互中“感觉卡”的地方，比如：

大量勾选迁移对象时

执行筛选、搜索列表时
可以把这些更新标记为低优先级，让输入、点击保持顺滑。

（这句是“理想路线图”，不用说已经做了，说“可以作为未来优化方向”。）

3️⃣ 网络 & 数据层还能做的
（1）引入更智能的接口缓存策略

现在你是：

Redux 存一些全局数据

列表靠分页接口

可以再往前走一步，比如引入：

请求级缓存：对短时间内重复访问的列表 / 详情做缓存

预取（prefetching）：

用户打开任务列表时，后台提前拉当前页+下一页

用户进入任务详情时，顺便拉关联的预检/日志信息

你可以这样讲：

这些属于“用户感知性能”的优化，虽然不一定减少 CPU 开销，但可以让用户觉得“点哪都秒开”。

（2）对搜索 / 筛选类操作统一做 debounce

比如在：

列表搜索框

过滤条件选择后触发请求

可以统一加一层 debounce（如 300ms）：

避免用户连续输入时打爆接口

减少前端状态频繁更新

这也是老项目常见可提升点。

4️⃣ 针对品牌替换这块的进一步优化
（1）逐步“从 DOM 替换 → 设计层替换”过渡

你的 MutationObserver 方案是 在历史包袱下的最佳折中，但从长远看可以逐步：

把还存在的 “dtle” 硬编码串迁移到 i18n 或 BrandConfig

对新写的代码，强制走品牌配置，而不是再写死字符串

最终让 MutationObserver 从“必需品”变成“兜底保障”，甚至逐步下线

这体现你有“技术债 → 逐步治理”的思路。

5️⃣ 可以直接对面试官说的一段总结

现在这个项目在性能上是“可用且稳定”的，但要说还能做什么优化，我大概会从几个方向继续做：

渲染层：现在已经对迁移对象选择做了虚拟滚动，后面可以把这套 VirtualList 能力抽象成通用组件，应用到更多大列表场景，同时用 profiler 把一些高频重渲染的组件找出来，用 memo / useCallback 做精细优化。

打包层：在已有 antd 按需加载的基础上，结合 bundle 分析做更细的路由级代码分割，把不常用模块拆成独立 chunk，缩小首屏 bundle 体积。

数据层：为列表类接口引入请求缓存 / 预取，对搜索、筛选操作统一做 debounce，提升用户的“主观性能体验”。

品牌替换：现阶段用 MutationObserver 是对历史项目的折中方案，后续可以通过逐步引入 BrandConfig / Provider，把品牌逻辑前移到设计层，从而减少对 DOM 层替换的依赖。

总体上，我会先用 profiler / bundle analyzer 把“真热点”找出来，然后按上面这些方向逐步去打磨，而不是为了优化而优化。

---

前端性能优化是一个多层面的工作，通常可以从 加载性能、渲染性能 和 交互性能 三个大方面来优化。下面是我常用的一些性能优化手段：

1️⃣ 加载性能优化
1.1 资源压缩与打包优化

JavaScript、CSS、图片资源压缩：利用工具如 Webpack、Terser、CSSNano 对 JavaScript 和 CSS 文件进行压缩，减少文件体积。

Tree Shaking：通过 Webpack 配置去掉无用的代码，确保只打包实际使用到的代码。

Code Splitting：将应用按路由或功能分块加载，确保初次加载时只加载当前页面所需的资源，其他页面或功能按需加载。

举例：
“我常用的打包优化技术包括 代码分割（Code Splitting） 和 Tree Shaking，确保只打包项目中实际使用的代码和模块，避免不必要的冗余，减小初始加载体积。”

1.2 图片和媒体资源优化

图片格式优化：使用适合的图片格式，如 WebP，比 JPEG 和 PNG 更加高效，特别适合需要高质量图像的场景。

响应式图片：根据不同设备和屏幕分辨率加载合适尺寸的图片。

图片懒加载：通过 IntersectionObserver 或 loading="lazy" 属性，使图片只有在进入视口时才加载，减轻首屏加载压力。

举例：
“我会根据设备的屏幕大小和分辨率使用 响应式图片，并采用 图片懒加载 来优化图片加载，确保用户不会在未进入视口前就加载图片。”

1.3 服务端渲染（SSR）和静态生成（SSG）

SSR：将页面在服务器端渲染并发送到客户端，减少首屏渲染的时间，尤其对 SEO 有帮助。

SSG：通过预渲染生成静态页面，使得页面加载速度极快，尤其适用于内容不经常更新的页面。

举例：
“我曾经在需要优化首屏渲染速度的项目中，采用了 服务端渲染（SSR），这样能在服务器端生成 HTML，客户端直接渲染，提高了首屏加载速度。”

2️⃣ 渲染性能优化
2.1 渲染时优化（减少重绘与重排）

避免频繁的 DOM 操作：在 JavaScript 中，避免频繁修改 DOM，尽量使用 documentFragment 或一次性更新 DOM 结构。

避免深层嵌套的 CSS 选择器：使用更高效的 CSS 选择器（例如避免 \* 通配符选择器，减少层级过深的选择器）。

举例：
“在 React 中，我会使用 React.memo 来避免不必要的子组件渲染，减少不必要的 diff 和重排，确保性能高效。”

2.2 使用虚拟滚动（Virtual Scrolling）

虚拟滚动：对于长列表，使用虚拟滚动技术（如 react-window 或 react-virtualized），只渲染可视区域的 DOM 元素，减少页面上渲染的 DOM 数量。

举例：
“在处理长列表（例如任务列表）时，我使用了 虚拟滚动 技术，通过 react-window 限制可视区域的渲染行数，极大地提升了渲染性能。”

2.3 使用 requestAnimationFrame 做动画优化

requestAnimationFrame：对于需要平滑过渡和动画的页面，使用 requestAnimationFrame 来执行动画，以确保动画平滑并且不会阻塞 UI 渲染。

举例：
“为了避免动画卡顿，我会使用 requestAnimationFrame 来执行高频动画操作，这样可以保证动画的流畅性，避免主线程阻塞。”

3️⃣ 交互性能优化
3.1 防抖与节流

防抖（Debouncing）：对于频繁触发的操作（如输入框的 onChange 事件、窗口尺寸变化等），使用防抖技术，减少事件触发频率，避免多次无意义的请求或操作。

节流（Throttling）：对于需要定时执行的操作（如滚动事件、resize 事件等），使用节流技术，控制事件的执行频率。

举例：
“我会使用 debounce 来限制用户输入时发起的请求，确保每次输入后只有在用户停止输入一定时间后才触发请求，这样可以减少网络请求数量。”

3.2 Web Workers 异步处理

Web Workers：通过 Web Workers 在后台线程处理耗时计算任务，避免阻塞主线程，使得 UI 渲染更加流畅。

举例：
“如果需要处理复杂的计算任务（如大数据处理、图像处理），我会考虑使用 Web Workers，将计算任务移到后台线程，避免阻塞主线程，确保页面流畅。”

3.3 使用 localStorage / IndexedDB 做数据缓存

本地缓存：将数据缓存到浏览器的 localStorage 或 IndexedDB 中，避免频繁的网络请求，提升应用响应速度。

举例：
“对于用户登录信息、权限等全局数据，我会存储在 localStorage 中，避免每次页面加载都向服务器发起请求。”

总结：面试官总结的高分回答模板

我了解并使用过多种前端性能优化手段，通常根据不同的场景采取不同的优化策略。

加载性能优化：包括代码分割、图片懒加载、按需加载、服务端渲染（SSR）等。

渲染性能优化：使用虚拟滚动、减少不必要的 DOM 操作、避免重排重绘、动画优化等。

交互性能优化：包括防抖与节流、Web Workers 异步处理、数据缓存（localStorage）等。

总体来说，性能优化是一个循序渐进的过程，不同的优化手段会在不同的阶段解决不同类型的性能瓶颈。

---

webp 图片和普通图片的区别
ChatGPT 说：
WebP 图片与普通图片的区别

WebP 是一种现代的图片格式，相较于传统的图片格式（如 JPG、PNG），它在图像压缩和质量方面具有许多优势。下面是 WebP 图片与普通图片格式（比如 JPEG、PNG、GIF）的一些关键区别：

1. 压缩效率与文件大小
   WebP

有损压缩和无损压缩：WebP 支持两种压缩方式：

有损压缩：比 JPEG 更高效，能在相同图像质量下减小文件大小。

无损压缩：在保证原图质量的同时，比 PNG 压缩更有效，减少文件大小。

文件大小更小：相同的图像质量，WebP 的文件通常比 JPEG 或 PNG 小 25% 到 34% 左右，甚至在某些情况下能压缩到 50% 以上。

普通图片（JPEG、PNG、GIF）

JPEG：常用于照片和复杂图像，压缩后文件较小，但会丢失部分细节。

PNG：支持无损压缩，适合需要透明度的图像（如图标、UI 元素），但文件大小较大。

GIF：适合简单动画，但只能支持 256 色，且文件大小较大。

总结：WebP 的压缩效率更高，通常能够提供更小的文件大小，尤其在有损压缩情况下，相比于 JPEG 或 PNG，WebP 显著减小了文件体积。

2. 图像质量
   WebP

保留更多细节：WebP 在有损压缩模式下，能够保留比 JPEG 更少的图像质量损失。在相同的文件大小下，WebP 比 JPEG 更能保留更多细节和更高的清晰度。

无损压缩：WebP 的无损压缩在保证图像质量的同时，文件大小显著减少，比 PNG 更具优势。

普通图片

JPEG：有损压缩，适合复杂图像或照片，但在高压缩时，细节可能会丢失，导致图像模糊或出现噪点。

PNG：无损压缩，图像质量不会有任何损失，但文件较大，适合图标、UI、透明背景图等。

GIF：适合简单动画，但颜色限制和较高的文件大小限制了其应用场景。

总结：WebP 提供更高质量的压缩，并支持透明度（像 PNG 一样），它在图像质量和文件大小之间找到了更好的平衡。

3. 支持的功能
   WebP

支持透明度（Alpha 通道）：WebP 支持透明背景，类似于 PNG，但文件大小较小。

动画支持：WebP 支持动态图像，类似于 GIF，但文件更小，质量更高。

普通图片

JPEG：不支持透明度或动画。

PNG：支持透明度，但不支持动画，文件较大。

GIF：支持动画，但颜色深度有限，且文件较大。

总结：WebP 比传统格式（JPEG、PNG、GIF）更具优势，它不仅支持透明背景和动画，而且能提供更高的压缩效率和更小的文件大小。

4. 浏览器支持
   WebP

支持度：WebP 最初的浏览器支持相对有限，但现在主流浏览器（如 Chrome、Edge、Opera、Firefox、Safari）都已全面支持 WebP 格式。虽然 iOS 上 Safari 从 2019 年起也开始支持 WebP，但仍然可能存在一些老旧设备的兼容性问题。

普通图片

JPEG、PNG 和 GIF：这三种格式在所有主流浏览器和设备上都有广泛支持，不会出现兼容性问题。

总结：WebP 在兼容性上仍略逊于传统格式，但随着浏览器对其的支持逐渐增强，WebP 已经成为越来越流行的选择。

5. WebP 与 JPEG/PNG 使用场景对比
   WebP 适用场景

Web 性能优化：WebP 格式是为了更高效的图片加载而设计的，适用于需要优化页面加载速度和减少流量消耗的网页和移动应用。

移动端应用：由于 WebP 提供了较小的文件大小，适合低带宽环境下使用，特别是在移动端。

支持透明度和动画的图片：WebP 在这两个方面的表现优于传统格式，适合做 Web 动画、图标、图片和图形元素。

JPEG 适用场景

摄影类图像：由于 JPEG 格式对自然图像（如风景、人物）非常有效，且文件体积较小，通常用于静态照片和复杂图像。

PNG 适用场景

UI 设计、透明背景图像：PNG 格式适用于要求透明度或高质量的图像，如图标、按钮、截图和屏幕图形元素。

GIF 适用场景

简单动画和小图标：适合用于展示动画或动态图标，但图像质量不高，且文件体积较大。

6. 总结

WebP 是一种高效的图像格式，提供了更高的压缩率、更小的文件大小，同时支持透明度和动画，非常适合 Web 和移动端的图像优化。

JPEG 适合处理复杂照片，文件较小，但不支持透明度和动画。

PNG 适合图标和 UI 元素，特别是需要透明度的场景，但文件较大。

GIF 适合简单动画，但质量差，文件较大。

推荐场景：如果需要优化网页加载速度、减少流量消耗，并且需要支持透明背景或动画，WebP 是一个非常好的选择。

---

前端首屏优化（First Screen Optimization）

首屏优化的核心目标是：尽快让用户看到页面的可用内容（提高感知加载速度）。

以下从加载、渲染、资源优化等角度总结常见方法：

✅ 1. 减少首屏关键资源体积（Critical Resources）

首屏渲染依赖的资源越少，渲染越快。

常见方式：

● 按需加载（Code Splitting）

利用 Webpack、Vite 的动态 import，把非首屏 JS 拆出去。

● Tree-Shaking

移除无用的 JS 代码。

● 去除不必要的 polyfill

使用 core-js + babel-preset-env 按需引入。

✅ 2. 减少网络传输时间
● 开启 gzip / brotli 压缩

Brotli 通常能比 gzip 小 20%+。

● 使用 CDN

缩短资源加载路径，加快静态资源下载。

● 预加载（preload / prefetch / dns-prefetch）

preload: 当前页必须的资源提前下载（如字体、首屏 CSS）

prefetch: 下一个页面可能用到的资源提前下载

dns-prefetch: 提前做 DNS 解析

✅ 3. 提升渲染速度（Rendering Optimization）
● 减少 CSS 阻塞

将关键 CSS 内联

非关键 CSS 使用 media 或 loadCSS

● 减少 JS 阻塞渲染

JS 放在底部

使用 defer 或 async

● 服务端渲染 SSR / 静态预渲染 SSG

SSR 能显著提升首屏，尤其 SPA 站点。

● CSR + Skeleton Screen 骨架屏

在真实内容加载前显示骨架屏 → 提升“感知速度”。

✅ 4. 图片优化（非常重要）

图片往往占总资源体积 60%+。

● 使用更高效格式：

WebP（通用）

AVIF（更小，但浏览器兼容性略差）

● 按需加载（Lazy Load）

只有在视口附近才加载。

● Responsive Image 响应式图片

<img srcset> 根据设备分辨率和宽度加载合适尺寸。

📊 前端性能衡量指标（Web Vitals）

Google 在 Web Vitals 中定义了现代 Web 的核心指标。

🔹 LCP（Largest Contentful Paint）最大内容绘制

衡量：页面主要内容加载的时间

理想值：小于 2.5s

典型影响因素：图片、视频、header 图、CSS

🔹 FID（First Input Delay）首次输入延迟

衡量：用户第一次交互（如点击）→ 浏览器能响应的时间

理想值：小于 100ms

主要与 JS 主线程阻塞有关。

🔹 CLS（Cumulative Layout Shift）累积位移

衡量：页面布局是否突然跳动

理想值：小于 0.1

常见原因：

图片未设置宽高

异步加载广告模块导致布局变化

🔹 FCP（First Contentful Paint）首次内容绘制

首次 DOM 内容（文字/图片）出现在屏幕上的时间。

🔹 TTI（Time to Interactive）可交互时间

页面可以真正响应用户操作的时间。

常被大型 JS 阻塞。

🔹 TBT（Total Blocking Time）总阻塞时间

衡量 JS 阻塞导致的不可交互时间。

🚀 总结

如果你只想记关键点：

首屏优化核心是三件事：

1. 更少的资源（减少体积 + 按需加载）
2. 更快地下载（CDN + preload + 压缩）
3. 更快渲染（SSR + 优化 CSS/JS + 图片优化）

性能指标核心是三条：

★ LCP – 加载快不快
★ FID – 点了是否马上响应
★ CLS – 页面跳不跳

---

🎯 总览：Chrome DevTools 性能分析最重要的 3 大面板
目的 使用面板
页面加载慢？首屏慢？ Network
JS 多？卡顿？掉帧？动画不流畅？ Performance（火焰图）
内存泄漏？页面越用越慢？ Memory

下面我会逐个讲解，附带完整操作步骤和解读方法。

📌 一、Network 面板 —— 诊断加载性能（首屏优化核心）
🔍 1. 打开方式

Chrome → F12 → Network

🔥 2. 打开关键设置

勾选 Disable cache

勾选 Preserve log

上方 Throttling 选择 Fast 3G（用于模拟低网速）

⭐ 3. 关注关键指标
（1）DOMContentLoaded（DOM 完成）

说明 HTML 已被解析完。

（2）Load（所有资源加载完）

说明页面加载完成。

（3）资源瀑布图（Waterfall）

重点看：

阻塞请求（长时间 “Stalled”）

CSS/JS 是否阻塞渲染

图片是否特别大

📌 重点操作：如何找首屏变慢的原因？
Step 1：按加载时间排序（Time）

找出 最慢资源
最常见：未压缩的 JS / 大图片 / CSS

Step 2：查看瀑布图中的颜色条

颜色说明一切：

黄色：等待时间（TTFB） → 服务器慢

蓝色：资源下载 → 文件太大

紫色：JS 执行 → 解析太慢

Step 3：找阻塞渲染的资源

点击某个 JS，可看到：

Render-blocking: Yes

此类 JS 会影响 FCP / LCP。

📌 二、Performance 面板 —— 分析卡顿、掉帧、JS 执行时间（最重要）
🔍 1. 打开方式

F12 → Performance

🔥 2. 录制分析（最关键步骤）

点击：

🔴 Record
→ 手动触发页面操作
→ 停止

⭐ 得到一个“火焰图”（Flame Chart）

这图告诉你：

CPU 花在什么 JS 上？

哪些函数执行时间最长？

哪些任务（task）阻塞主线程？

页面为何卡顿？

渲染管线（Raster → Composite → Paint）的具体情况

🔥 火焰图最重要的 5 个区域
1）Summary（整体摘要）

FPS（帧率）是否有掉帧

CPU 占用情况

内存趋势

网络请求情况

FPS 低于 60 → 页面卡顿。

2）Frames（每一帧情况）

红条 = 掉帧
黄条 = 慢 JS

3）Main（主线程火焰图） → 最重要

🔥 火焰图中的宽度 = 执行时间
越宽说明越耗时。

重点关注：

颜色 意义
黄色 JavaScript 执行
紫色 Layout（布局计算）
绿色 Paint（绘制）
蓝色 网络、解析资源

常见性能问题都在这里找得到：

❗ 长任务（Long Task > 50ms）

Chrome 会标记为：

⚠️ Long Task

这是造成交互延迟（FID）和卡顿的直接原因。

4）Bottom-Up / Call Tree（函数耗时分析）

你可以直接看到：

函数名 调用次数 总耗时 自身耗时（Self Time）

非常适合找 React/ Vue 组件性能瓶颈、JS 循环、重绘重排等问题。

5）Timings（关键事件）

能看到：

FCP

LCP

CLS

TTI

Script Evaluation 时间

对 Web Vitals 分析非常有用。

📌 三、Memory 面板 —— 找内存泄漏（组件重复渲染/监听未清理）

用途：

页面越用越卡？

来回切换页面后内存不下降？

SPA 是否有内存泄漏？

1. 多种模式
   ● Heap Snapshot（堆快照）

拍摄当前内存，找未释放对象。

● Allocation Timeline（随时间变化）

能看到“内存是否不断上涨”。

● Allocation sampling（采样）

找最耗内存的函数。

2. 如何找泄漏？
   Step 1：拍 3 张快照

1️⃣ 初始 → Snapshot 1
2️⃣ 操作页面（进出页面）→ Snapshot 2
3️⃣ GC（垃圾回收）后 → Snapshot 3

对比：

Snapshot 3 > Snapshot 1 → 内存泄漏

某些对象数量持续上升 → 监听没解绑、定时器未清理、闭包引用未释放

📌 四、Performance Insights（新手特别好用）

在 Chrome 最新版中：

👉 DevTools → More Tools → Performance Insights

它会自动告诉你：

哪个图片太大

哪个 JS 太慢

哪个 CSS 阻塞

哪个任务太长

几乎不需要手动分析，非常适合快速定位问题。

📌 五、Web Vitals 分析（LCP / FID / CLS）

在 Performance 录制后：

在 Timings 区域能看到：

指标 代表什么
FCP 首次内容
LCP 最大元素加载
CLS 布局跳动
TTI 何时可交互
TBT 总阻塞时间
如何定位 LCP 来源？

在 Timings 中点击 LCP → DevTools 自动跳到对应 DOM 元素（通常是图/大标题）。

🎉 总结：用 DevTools 性能分析的最佳流程

👇 推荐你直接照着做（超实用）

📌 Step 1：Network 诊断加载慢的原因

是否有大资源？

是否有阻塞 CSS/JS？

是否 TTFB 很高（服务器问题）？

📌 Step 2：Performance 火焰图找卡顿原因

FPS 是否掉帧？

是否有 Long Task？

哪些 JS 最耗时？

Layout / Paint 是否频繁？

📌 Step 3：Memory 检查是否存在泄漏

拍快照对比

分析对象数量

📌 Step 4：看 Web Vitals（很关键）

LCP 是否超过 2.5s？

CLS 是否超过 0.1？

TTI 是否太慢？

---

先说结论：首屏优化的本质 = 缩短“用户看到主要内容”的时间（LCP/FP） + 提升“看起来很快”的感知速度。
下面我给你一套通用方案，然后分别细化到 Vue / React / Next.js / 小程序，你可以当 checklist 用。

一、先定目标 & 量化指标
🎯 目标建议

LCP（Largest Contentful Paint）：≤ 2.5s

FCP（First Contentful Paint）：≤ 1.5s

TTI（Time To Interactive）：≤ 5s（视项目复杂度）

首屏请求数量：尽量 ≤ 30 个（含图片/接口）

首屏 JS 体积（gzip 后）：尽量 ≤ 150–200 KB

工具

Web 端：Chrome DevTools + Lighthouse + WebPageTest

小程序：微信开发者工具「性能」面板

二、通用首屏优化方案（适用于所有端）
1️⃣ 构建 &代码层优化

首屏路由代码拆分

仅加载当前路由必要 JS

非首屏页面 动态 import，避免一次性打包全部

Tree-Shaking + 去掉死代码

用构建工具（Vite/Webpack）做 Tree Shaking

拆掉大而全的 utils/组件库，按需引入

第三方库瘦身

尽量避免：moment、lodash 全量

使用：

dayjs 替代 moment

lodash-es + 按需引

可选：把极大但不影响首屏的库改为 异步加载

2️⃣ 网络与缓存策略

CDN

所有静态资源（JS/CSS/图片/字体）放 CDN

域名分离，减轻主域名负载

HTTP 缓存

对版本化静态资源：Cache-Control: max-age=31536000, immutable

HTML 禁缓存或短缓存 + ETag

预连接 & 预解析
在 <head> 中：

<link rel="dns-prefetch" href="//cdn.xxx.com">
<link rel="preconnect" href="https://cdn.xxx.com" crossorigin>

preload / prefetch

首屏必须的 CSS/关键字体：<link rel="preload">

预计下一步用户会去的路由：prefetch（Next.js 可自动）

3️⃣ 渲染路径优化

CSS 阻塞优化

首屏关键 CSS 内联（Critical CSS）

非首屏样式拆分为异步 CSS

JS 阻塞优化

尽量用 defer（<script src="xxx.js" defer>）

把监控、埋点、广告脚本延后加载（onload 后）

Skeleton 骨架屏 / Loading 占位

（非常关键）首屏内容未就绪时，用骨架屏填充，提升感知速度

骨架屏设计 = UI 结构的简化版

4️⃣ 资源（图片/字体）优化

图片

使用 WebP/AVIF（兼容情况允许）

控制尺寸，避免手机上加载桌面级图片

懒加载：首屏仅加载视口范围内必要图片

字体

避免使用多个字体文件，减少字重

字体文件使用 preload + font-display: swap（防止白屏）

5️⃣ 首屏数据加载策略

尽量合并请求

几个小接口合并为一个首屏接口

使用 HTTP/2 时仍然要控制接口数量

优先获取首屏必需数据，延迟非核心数据

页面首屏区块的数据优先请求

评论区、推荐卡片等延迟/懒加载

适度“乐观 UI”

某些非关键数据用静态兜底，接口返回后再更新

三、针对 Vue SPA 的首屏优化
1️⃣ 路由按需加载
const Home = () => import('@/pages/Home.vue')

const routes = [
{ path: '/', component: Home },
]

2️⃣ 组件与 UI 库按需引入

使用 unplugin-vue-components 做自动按需引入

UI 库（Element Plus、Vant 等）一定不要全量引

3️⃣ SSR / 预渲染（可选）

SEO/首屏要求高 → 使用 Nuxt / Vue SSR

纯展示页 → 用 prerender-spa-plugin 做静态预渲染

4️⃣ 首屏骨架屏

为 / 路由单独做 Skeleton 组件，在数据没回来前展示

四、针对 React SPA 的首屏优化
1️⃣ 路由 & 组件懒加载
const Home = React.lazy(() => import('./pages/Home'))

<Routes>
  <Route
    path="/"
    element={
      <React.Suspense fallback={<HomeSkeleton />}>
        <Home />
      </React.Suspense>
    }
  />
</Routes>

2️⃣ 减少首屏 hydration 压力（如果将来 SSR）

避免首屏加载太多复杂组件（大表格/图表）

把非首屏组件改为「客户端懒加载 + 占位」

3️⃣ 监控首屏性能

用 web-vitals 或自定义打点上报 LCP/TTI

五、针对 Next.js（重点：SSR/SSG + 图片优化）

Next 本身就是为首屏性能和 SEO 生的，我们利用好它的内建能力即可。

1️⃣ SSG / ISR / SSR 策略

能静态的尽量静态：

营销页、文章等：generateStaticParams / SSG

数据几分钟更新一次：ISR（增量静态再生成）

只有对实时性特别高的页面才用 SSR

2️⃣ 使用 next/image 做图片优化
import Image from 'next/image'

<Image
src="/banner.jpg"
alt="banner"
width={800}
height={400}
priority // 首屏图片建议加上
/>

自动按需生成不同尺寸

支持懒加载、格式优化

3️⃣ Script 优化
import Script from 'next/script'

<Script src="https://xx.com/analytics.js" strategy="afterInteractive" />
<Script src="https://xx.com/ads.js" strategy="lazyOnload" />


避免监控、广告阻塞首屏。

4️⃣ 字体优化

使用 next/font/local / next/font/google

自动生成最佳字体加载策略，减少 FOIT/FOUT 问题

六、针对 小程序（微信等） 的首屏优化

小程序首屏跟 H5 略有不同，但原则一致：减包体、减首屏 setData、减接口数。

1️⃣ 分包 & 分包预加载

把非首屏页面放到 分包

对高频路径使用 分包预加载，加快后续打开速度

首包尽可能控制在 2M 以内

2️⃣ 减少首屏 setData 量

避免一次 setData 大 JSON

使用局部更新、拆分多次小 setData（但也不要过度频繁）

3️⃣ 首屏接口合并

用一个首页接口返回导航/卡片/列表摘要数据

首屏只展示摘要，详情页再请求详情数据

4️⃣ 组件 & WXML 优化

控制首屏节点数量，不要 DOM 数千个

复杂长列表可以首屏只给前几项 + 滚动加载

5️⃣ 图片与资源

提前放 CDN，使用合适尺寸

icon 合并成雪碧图或字体图标（在合适场景下）

七、落地执行的 Checklist（建议你直接照做）
🧩 阶段 1：现状评估

跑 Lighthouse 看：

Performance / Best Practices / LCP / TTI

用 Chrome DevTools 的 Network + Performance 分析：

首屏请求数

首屏 JS/CSS 体积

Long Task 有哪些

🧩 阶段 2：快速收益项（1～2 周能做完）

打开 Gzip/Brotli、上 CDN

路由级代码分割（Vue/React/Next）

首页 Skeleton 骨架屏

图片全部压缩 & 支持 WebP

合并首屏接口

🧩 阶段 3：中长期优化

引入 SSR/SSG（Nuxt / Next）

重构过大的组件（表格、复杂列表）

建立 web-vitals 埋点体系

建立性能预算（performance budget）：超标报警 -->
