# api 生成工具

## 整体流程概览

1. 读取后端的 swagger.json 文件
2. 解析并按照 tag 对接口进行分类
3. 把`definitions`对象转换为公共的 TS 类型
4. 把每个接口 `path/method` 变成一个 Service 类上的方法+对应的 Params/Return
5. 将最终结果写入 src/api 目录下

## 详细解析

### 第一步：读取并预处理 swagger.json

#### 读取文件 + 运行插件

```js [src/json/index.ts]
public handleSwaggerJsonFile (swaggerJsonSrc: string): ISwaggerJson {
  console.log(`start read swagger.json...;current src of find: ${swaggerJsonSrc}`)
  const swaggerJson = fs.readFileSync(swaggerJsonSrc);
  console.log(`read swagger.json end`);
  let json = this.plugin.runPlugin('swaggerJson', swaggerJson.toString());
  if (!json) {
    json = JSON.parse(swaggerJson.toString());
  }
  return json;
}

public getApiData (swaggerJsonSrc: string) {
  console.log(`start generate api data from swagger.json...`);
  const swaggerObj = this.handleSwaggerJsonFile(swaggerJsonSrc);
  const definitions = swaggerObj.definitions;
  const parameters = swaggerObj.parameters;
  const apiMap = this.generateApiMap(swaggerObj);
  return { definitions, apiMap, parameters }
}


```

#### 按 tag 归类接口`paths → Map<tag, paths[]>`

```js [src/json/index.ts]
public generateApiMap (swaggerJson: ISwaggerJson): Map<string, ISwaggerPaths[]> {
  const apiMap = new Map<string, ISwaggerPaths[]>();
  const paths = Object.keys(swaggerJson.paths);
  paths.forEach(path => {
    const currentApi = swaggerJson.paths[path];
    const keys = Object.keys(currentApi);
    for (let i = 0; i < keys.length; i++) {
      const apiMethod = keys[i];
      if (CommonData.RequestMethod.includes(apiMethod)) {
        if (!currentApi[apiMethod].tags) {
          throw new Error(...);
        }
        const currentTag = currentApi[apiMethod].tags[0];
        if (apiMap.has(currentTag)) {
          apiMap.get(currentTag).push({ [path]: currentApi });
        } else {
          apiMap.set(currentTag, [{[path]: currentApi}]);
        }
        break;
      }
    }
  })
  return apiMap;
}
```

#### 默认插件 `plugin.js` 对 definitions 和 `$ref` 做一次清洗（把带 `.` 的名字规整一下）：

```js [plugin.js]
swaggerJson(swaggerJsonStr) {
  const swaggerJson = JSON.parse(swaggerJsonStr);
  this.removeDot(swaggerJson);
  Object.keys(swaggerJson.definitions).forEach((key) => {
    const newKey = key.split('.')[1];
    swaggerJson.definitions[newKey] = swaggerJson.definitions[key];
    delete swaggerJson.definitions[key];
  });
  return swaggerJson;
}
```

---

### 第二步：生成公共类型（`common.d.ts` / `common.enum.ts`）

`Core.generateApi()` 会先把 swagger 的 `definitions` 统一转成 TS 类型 / 接口 / 枚举：

```js [src/core/index.ts]
public generateApi() {
  console.time('generate success');
  this.registerPlugin();
  const apiData = Json.getApiData(this.swaggerJsonSrc);
  this.commonParamDefined = apiData.parameters;
  this.generateCommonInterface(apiData.definitions);
  write.writeFile(
    this.outputSrc + '/common.d.ts',
    this.commonInterfaceBuffer
  );
  if (this.commonEnumBuffer !== '') {
    write.writeFile(
      this.outputSrc + '/common.enum.ts',
      this.commonEnumBuffer
    );
  }
  ...
}
```

`generateCommonInterface` 会：

1. 识别简单枚举（基础类型 + enum）→ 写入 `common.enum.ts`
2. 识别普通对象 / map / array → 写成 `interface IXXX {...}` 或 `type IXXX = ...`
3. 使用内部的 `getTypeFromArray` / `getTypeFromObject` / `traverseObject` 把嵌套结构、`$ref`、`additionalProperties` 等转换为 TS 类型，并维护 import 关系

```js [src/core/index.ts]
public generateCommonInterface(definitions: ISwaggerDefinitions) {
  const specialKeys = Object.keys(definitions).filter((item) =>
    Object.keys(this.typeDictionary).includes(definitions[item].type)
  );
  ...
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (Object.keys(this.typeDictionary).includes(definitions[key].type)) {
      if (definitions[key].enum && this.validEnum(definitions[key].enum)) {
        let enumName = CommonData.removeSpecialStr(
          `${key[0].toUpperCase()}${key.slice(1)}Enum`
        );
        ...
        this.commonEnumBuffer += template.enumTemplate({ enumName, body: enumBody });
        this.addValue(this.commonInterfaceImport, 'common.enum', enumName);
        this.commonInterfaceIsEnum.push(key);
        continue;
      } else {
        this.commonInterfaceIsNormalType.set(key, definitions[key].type);
        continue;
      }
    }
    const currentInterfaceName = `I${key}`;
    ...
    this.commonInterfaceBuffer += template.interfaceTemplate(
      currentInterfaceName,
      currentInterfaceBody
    );
  }
  ...
  this.commonInterfaceBuffer = importListStr + this.commonInterfaceBuffer;
}
```

### 第三步：每个 tag 生成一个 Service 类 + 参数/返回类型

在 `generateApi()` 中，对每个 tag（即 controller 分组）：

```js [src/core/index.ts]
for (const [key, value] of apiData.apiMap) {
  this.interfaceBuffer = "";
  this.interfaceImportList = new Map();
  this.enumBuffer = "";
  this.classImportList = new Map();
  const currentFile = `${this.outputSrc}/${key}`;
  const classBody = this.generateMethod(value);
  let className = CommonData.removeSpecialStr(key);
  const classFile = this.generateClass(className, classBody);
  write.writeFile(`${currentFile}/index.ts`, classFile);
  write.writeFile(`${currentFile}/index.d.ts`, this.interfaceBuffer);
  if (this.enumBuffer) {
    this.addSpecialContentInEnumFile();
    write.writeFile(`${currentFile}/index.enum.ts`, this.enumBuffer);
  }
}
```

结果在前端项目中形成结构类似：

- `src/api/common.d.ts` / `common.enum.ts` / `Service.base.ts`
- `src/api/<TagName>/index.ts`：一个 `XXXService` 类，包含多个方法
- `src/api/<TagName>/index.d.ts`：这个 tag 下所有 `Params` / `Return` 接口
- `src/api/<TagName>/index.enum.ts`（可选）：该 tag 自己的枚举

### 第四步：从 swagger path 映射到类方法签名

主逻辑在 `generateMethod`：

```js [src/core/index.ts]
public generateMethod(methods: ISwaggerPaths[]) {
  let body = '';
  methods.forEach((method) => {
    Object.keys(method).forEach((url) => {
      Object.keys(method[url]).forEach((requestMethod) => {
        if (CommonData.RequestMethod.includes(requestMethod)) {
          const paramsMap = new Map();
          const currentParams: ISwaggerParameters[] =
            method[url][requestMethod].parameters || [];
          currentParams.forEach((param) => {
            paramsMap.set(param.name, param.in);
          });
          const operationId = method[url][requestMethod].operationId;
          const paramsInterface = this.getParamsInterface(
            currentParams,
            operationId
          );
          const returnInterface = this.getReturnInterface(
            method[url][requestMethod].responses[200].schema,
            operationId
          );
          body += template.methodTemplate({
            methodName: operationId,
            paramsInterface: paramsInterface,
            returnInterface: returnInterface,
            url: url,
            requestMethod,
            paramsMap,
            consumes: method[url][requestMethod].consumes || [],
          });
          if (paramsInterface.endsWith('Params')) {
            this.addValue(this.classImportList, 'd', paramsInterface);
            this.generateParamsInterface(
              paramsInterface,
              method[url][requestMethod].parameters,
              operationId
            );
          }
          if (returnInterface.endsWith('Return')) {
            this.addValue(this.classImportList, 'd', returnInterface);
            this.generateReturnInterface(
              returnInterface,
              method[url][requestMethod].responses[200].schema,
              operationId
            );
          }
        }
      });
    });
  });
  ...
  this.interfaceBuffer = importListStr + this.interfaceBuffer;
  return body;
}
```

关键点：

- **方法名**：`operationId` 直接作为 TS 方法名。
- **请求方法**：`requestMethod` 决定调用 `this.get / this.post / ...`。
- **路径参数 / query / header / body** 在 `getParamsInterface` 和 `generateParamsInterface` 里决定是否需要生成 `I<OperationId>Params` 接口，同时按 swagger 的 `in: 'body' | 'query' | 'path' | ...` 分析字段类型。
- **返回类型**在 `getReturnInterface` / `generateReturnInterface` 里，根据 `responses[200].schema` 推导：
  - 基本类型 / 数组 / `$ref` 到 `definitions` / 内联 object → 对应 TS 类型或 `IxxxReturn` 接口。

### 第五步：模板如何生成最终的“接口函数”

实际的前端接口函数是写在每个 Service 类里，由模板 `Template.methodTemplate` 生成：

```js [src/template/index.ts]
public methodTemplate({
  methodName,
  paramsInterface,
  url,
  requestMethod,
  paramsMap,
  returnInterface,
  consumes,
}: IMethodTemplateParams) {
  let paramsHandle = '';
  let currentUrl = url;
  let formDataParams = '';
  let headerParams = '';
  let pathParamsDeleteCode = '';
  if (currentUrl.includes('{')) {
    const urlArray = currentUrl.split('/');
    for (let i = 0; i < urlArray.length; i++) {
      if (urlArray[i].startsWith('{')) {
        const paramsName = urlArray[i].slice(1, -1);
        urlArray[i] = `$${urlArray[i]}`;
        pathParamsDeleteCode += `
          const ${paramsName} = paramsData.${paramsName};
          delete paramsData.${paramsName};
        `;
      }
    }
    currentUrl = urlArray.join('/');
  }
  for (let [key, value] of paramsMap) {
    switch (value) {
      case 'header':
        headerParams += `
      ${key}: params.${key},
        `;
        break;
      case 'formData':
        const paramsKeyStr = `params${
          key.includes('-') ? `['${key}']` : `.${key}`
        }`;
        formDataParams += `
          if (${paramsKeyStr} != undefined) {
            paramsData.append('${key}', ${paramsKeyStr} as any);
          }
        `;
        break;
    }
  }

  if (
    formDataParams &&
    consumes.includes('application/x-www-form-urlencoded')
  ) {
    formDataParams = `
      const paramsData = new FormData();
      ${formDataParams}
    `;
    headerParams += `
      'Content-Type': 'multipart/form-data'
    `;
  } else {
    formDataParams = '';
  }

  if (headerParams) {
    headerParams = `
      const config = options || {};
      const headers = config.headers ? config.headers : {};
      config.headers = {
        ...headers,
        ${headerParams}
      };
    `;
  }

  return `
    public ${methodName}(${
    paramsInterface ? `params: ${paramsInterface}, ` : ''
  }options?: AxiosRequestConfig) {
      ${headerParams ? headerParams : ''}
      ${
        formDataParams
          ? formDataParams
          : paramsInterface
          ? 'const paramsData = this.cloneDeep(params);'
          : ''
      }${!formDataParams && paramsInterface ? pathParamsDeleteCode : ''}
      return this.${requestMethod}${
    returnInterface ? `<${returnInterface}>` : ''
  }(${currentUrl.includes('$') ? '`' : "'"}${currentUrl}${
    currentUrl.includes('$') ? '`' : "'"
  }, ${paramsInterface ? 'paramsData' : 'undefined'}, ${
    headerParams ? 'config' : 'options'
  });
    }
  `;
}
```

特征：

- **path 参数**：把 `/users/{id}` 转成模版字符串 `` `/users/${id}` ``，并从 `paramsData` 抽出 `id` 后删除，避免进 query/body。
- **`formData` 参数**：根据 swagger 中 `in: 'formData'` 自动构建 `FormData` 实例并设置 `multipart/form-data` header。
- **header 参数**：`in: 'header'` 的字段会合并到 `AxiosRequestConfig.headers`。
- **调用方式**：最终方法内部调用 `this.get/post/...`，由 `ServiceBase` 统一封装 Axios：

```js [src/template/index.ts]
public serviceBaseTemplate() {
  return `
  import { AxiosRequestConfig } from 'axios';
  import { cloneDeep } from 'lodash';
  import ApiBase from '../utils/Api';

  class ServiceBase {
    protected get<T>(url: string, data: any = {}, options?: AxiosRequestConfig) {
      return ApiBase.get<T>(url, {
        params: data,
        ...options,
      });
    }
    ...
  }
  export default ServiceBase;
  `;
}
```

每个 tag 的类本身通过 `classTemplate` 生成，例如：

```js [src/template/index.ts]
public classTemplate({ className, body, importList }: IClassTemplateParams) {
  ...
  class ${className}Service extends ServiceBase {
  ${body}
  }

  export default new ${className}Service();
}
```

这就把 swagger 里的每个 path/method 变成了 **前端可以直接调用的 service.method(params, options)**，并且 params、返回值都有对应的 TS 类型约束。

---

### 第六步：写文件与格式化

最后所有生成内容通过 `Write.writeFile` 落盘，并用 Prettier 按 TypeScript 风格自动格式化：
