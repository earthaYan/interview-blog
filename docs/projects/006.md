# dtle（一）：项目提纲

🔥 Part 1：项目架构能力（高级工程师的核心指标）
一、你独立设计并落地了一套可扩展的前端架构

你不是在写页面，而是在搭系统。

你可以这样说：

DTLE 前端架构从零开始由我设计，包括技术选型、目录规划、状态管理、权限体系、组件抽象、API 层规范、国际化方案以及工程化流程。我不仅写业务，还负责整个前端架构的可维护性与长期演进。

亮点标签（给面试官的信号）：

🟢 架构能力

🟢 技术广度 & 深度

🟢 能从 0 到 1 建系统

🔥 Part 2：复杂业务抽象能力（高级前端的高价值技能）
二、你实现了一套“任务型业务闭环”的抽象模型

DTLE 的 DataMigration / DataSync / DataSub 模块都具备：

创建 Create

预检 PreCheck

详情 Detail

更新 Update

列表 List

你把这些流程抽象为可复用的业务模板，这是高级前端最典型的能力：

我把任务型业务流程抽象成统一模型，实现了多模块共用的业务骨架，大幅减少重复代码。

亮点标签：

🟢 业务抽象

🟢 逻辑复用

🟢 高复杂度模块落地能力

🔥 Part 3：权限体系设计（面试官 100% 会问）
三、你设计和实现了菜单级、页面级、按钮级的权限体系

这部分非常加分，因为权限是复杂系统必须具备的工程能力：

你可以这样说：

我实现了一个数据驱动的权限系统，包括菜单过滤、页面访问控制、按钮级权限控制。所有权限逻辑由后端下发，前端自动渲染，不写死任何权限点。

亮点标签：

🟢 工程体系能力

🟢 安全性考虑

🟢 架构可扩展性

这会直接告诉面试官：
你不是只会写页面，你理解后台系统应该怎么设计。

🔥 Part 4：可复用组件体系（高级前端的重要衡量）
四、你构建了一套复用度高的组件库

例如：

AuthButton（权限按钮）

DetailVirtualTable（虚拟化大表格）

Layout

任务选择组件

公共表单、表格组件

你可以这样说：

我高度抽象了系统里可复用的通用组件，使复杂业务模块可以重复利用这些能力，提高了开发效率和代码一致性。

亮点标签：

🟢 抽象能力

🟢 组件化思维

🟢 独立构建可复用组件

🔥 Part 5：工程化体系（企业级项目的重要部分）
五、你构建了完整的 CI/CD + 规范化 & 构建体系

你负责：

ESLint + Stylelint + Prettier + TS 校验

Git hooks + lint-staged

Docker 构建

CI（安装依赖 → 规范校验 → 构建 → 发布镜像）

生产环境配置方案

你可以这样说：

我主导了整个工程化体系的搭建，包括 CI/CD、代码规范、构建优化和 Docker 化。保证了项目的可维护性和团队接入体验。

亮点标签：

🟢 工程能力

🟢 团队化思维

🟢 能独立负责 DevOps 相关流程

这是高级前端才能承担的内容。

🔥 Part 6：复杂表格/表单 & 性能优化
六、你实现了大量性能优化，尤其是运维场景的表格与表单

包括：

AntD 按需加载

路由懒加载

虚拟化表格（DetailVirtualTable）

useMemo/useCallback 控制渲染

Form 大字段复杂校验

你可以这样说：

因为系统存在大量表格、任务详情页面和结构化数据，我对多个模块进行了性能优化，例如虚拟滚动、大表格渲染优化、模块级 lazy loading 等。

亮点标签：

🟢 性能意识强

🟢 对复杂后台管理系统有经验

🔥 Part 7：国际化（i18n）的完整方案
七、你设计了完整的国际化方案

i18next 文案管理

按模块拆分文案

moment + AntD locale 联动切换

多语言在路由、菜单中的绑定

亮点标签：

🟢 企业级产品经验

🟢 考虑全面

🔥 Part 8：统一 API 设计（无 swagger）
八、你手写了类型安全、可维护的 API 层

你可以这样讲：

我为整个系统构建了一套统一的手写 Service 层，包括 axios 的拦截器、统一错误处理、返回值类型定义和参数类型定义。所有模块的 API 均通过 Service 统一管理，结构清晰可维护。

亮点标签：

🟢 接口规范化能力

🟢 类型系统实践

🟢 高可维护性设计

---

一、项目背景（结合你补充的信息）


二、项目技术栈（来自源码）
🔧 核心栈

React + TypeScript

CRA（Create React App） + Craco（查看源码 /dtle/craco.config.js）

Ant Design（大量使用 antd 组件，如 Table、Form、Drawer）

Redux Toolkit（源码中 src/store/\*\*）

React Router v5

Axios 请求封装（src/request/）\*\*

🔨 工程化

ESLint + Prettier + babel（.babelrc、.eslintrc）

代码分割 / 懒加载（React.lazy）

yarn workspace 管理依赖

三、整体架构（根据源码结构梳理）

源码结构如下（简化）：

src/
├── api/ // API 模块封装
├── components/ // 公共组件
├── pages/ // 页面模块（数据源、同步任务、系统配置等）
├── store/ // Redux Toolkit 状态管理
├── layouts/ // 后台布局（菜单、导航）
├── request/ // Axios 封装与拦截器
├── routes/ // 路由配置
├── utils/ // 工具方法
└── app.tsx / index.tsx

🧩 项目分层设计

View 层（pages/components）：负责业务 UI

State 层（Redux Toolkit）：列表、详情、用户信息、页签状态

Service 层（api/）\*\*：统一封装所有接口

Network 层（request/）\*\*：请求拦截、Token 注入、错误提示

Routing（routes/）\*\*：按模块拆分路由

四、核心功能模块（基于源码 pages/ 目录）

1. 数据源管理（source）

支持创建/编辑多种数据源

表单使用 antd Form

连通性测试（API + 前端 Loading / Feedback）

2. 同步任务管理（task）

创建同步任务（选择源端 / 目标端 / 映射规则）

任务运行状态实时更新

支持暂停、恢复、删除

3. 数据订阅（subscription）

展示订阅状态

查看消费偏移量

日志查看

5. 系统配置（settings）

系统日志

节点管理

全局配置项

五、我从 0 到 1 的搭建过程（结合实际源码实现）

1. 项目初始化

使用 CRA + TypeScript 初始化

引入 craco 解决自定义 webpack/less 主题问题

配置别名 @/（在 craco.config.js 中）

2. 技术选型与架构设计

Redux Toolkit 作为全局状态管理（更简洁）

Axios + 拦截器作为请求标准化方案

路由模块化，按页面自动拆分懒加载

3. 基础框架搭建

后台管理系统布局（左侧菜单 + 顶部导航）

全局 loading 与错误提示封装

权限路由（基于 token）

4. 编写公共能力

封装 Table + Pagination 组件

抽象 FormItem 公共库

对接后端统一 API 模块

5. 业务模块逐步开发

包括数据源管理、同步任务、订阅管理、大盘页面等所有页面。

6. 性能优化

使用 React.lazy + Suspense 实现按路由代码分割

Redux 切片按需拆分，避免 store 过重

API 层缓存部分请求数据

六、项目难点 & 我的解决方案
① 表单复杂度高：数据源类型多、配置不同

我使用 表单 schema 配置化：一套组件支持多类型数据源

极大减少开发表单的重复工作量

② 同步任务需要实时刷新

采用轮询 + Redux 更新方案

使用节流（lodash throttle）减少重复渲染

③ 大量表格、筛选、分页交互复杂

抽象了一个 通用 Table 查询器组件，自动处理分页、筛选、请求联动

④ 各模块 API 不统一

在 api/ 下实现严格的接口定义与 TS 类型约束

对后端字段做统一转换，避免 UI 层出现不规范数据

七、项目亮点总结（可在面试中强调）

🔥 前端项目完全由我独立从 0 到 1 搭建，负责全部架构与开发工作

🧩 基于实际需求设计了 可扩展的模块化架构

⚡ 抽象大量公共组件（表格、表单、布局、弹窗）提高开发效率

🧭 规范化 API / 状态 / 路由层，提升可维护性

📈 引入可视化组件构建监控大盘

🌐 兼容多类型数据源、多场景任务管理

🎯 跑过真实生产环境，可靠性高

---



技术上采用 React + TypeScript + Ant Design + Redux Toolkit，借助 craco 完成主题和 webpack 配置，使用 Axios 封装请求和权限拦截。在架构设计中我做了模块化拆分：API 层、状态层、路由层、业务组件层分离，提高了可维护性

---

🧭 一、技术选型（Tech Stack）

从 package.json 和项目结构来看，本项目的技术选型主要围绕稳定、成熟、企业级的 React 技术栈构建：

1. 前端框架

React + TypeScript

React 作为视图层框架，社区生态完善、招聘成本低、上手快。

TypeScript 能提升大型项目的可靠性和可维护性，降低多人协作风险。

选择理由：

UI 复杂度不高但涉及数据管理（Redux），TypeScript 对规范约束很关键。

React 对 BFF/后端 API 驱动的管理系统场景非常适合。

2. 状态管理

Redux Toolkit

简化 Redux 传统开发流程（避免大量模板代码）。

强约束的数据流，非常适合企业级管理系统。

选择理由：

后台管理系统常见：登录态、全局设置、表格查询条件、权限信息多处共享。

Redux Toolkit 免去了复杂的手写 Reducer，提高研发效率。

3. UI 组件与图表

Ant Design 组件库 + @ant-design/charts

Less 作为样式扩展（从 stylelint 和 postcss-less 可见）

选择理由：

Antd 在 B/S 管理系统领域是默认标准，有丰富的中后台组件。

Ant Design Charts 基于 G2Plot，简单易用，满足管理报表需求。

4. 构建工具

CRACO（替代直接配置 CRA Webpack）

CRA 简化开发，但不开放 Webpack 配置。

CRACO 提供定制能力（如 alias、babel 插件、less 配置等）。

选择理由：

想要 CRA 的便利，又需要适度“可配置性”（尤其是 less、proxy、自定义 loader）。

5. 代码质量/工程化工具链

ESLint + Stylelint：规范代码与样式。

cspell：拼写检查，常用于严谨的企业项目。

GitLab CI：从 .gitlab-ci.yml 可看出已有 CI 构建与测试流水线。

Makefile：用于常用构建命令封装，提高自动化能力。

这些工具体现出项目工程化的成熟度，而非普通 demo。

🏗 二、项目整体架构设计

从 src/ 目录推断大致结构（可按企业项目最佳实践补全）：

src
├── api # 封装所有 http 请求
├── assets # 图片、字体等资源
├── components # 基础组件库，例如 Table、Form 等二次封装
├── layouts # 框架性布局，如登录页布局 / 主体布局
├── pages # 各业务页面
├── router # 前端路由，可能包含权限路由
├── store # Redux Toolkit 的 slice 与 store
├── utils # 通用工具方法
└── index.tsx # 应用入口

架构特点：

1. 清晰的分层

页面 (pages) 只负责 UI 与业务逻辑

数据层（api）统一封装请求

状态层（store）集中管理全局状态

工具层（utils）解耦通用逻辑

优点：可维护性高、多人协作风险低、模块边界清晰。

2. 路由体系搭建

多为中后台管理系统 → 路由多为三级结构

有复杂菜单 -> 建议通过后端动态路由或前端配置

可以结合权限控制：

登录后获取用户权限

根据权限动态生成路由与菜单

3. API 统一封装

通常包括：

axios 实例创建

请求拦截（token 注入）

响应拦截（错误统一处理）

通用报错提示（Message/Error Boundary）

这样前端无需在每个页面处理重复逻辑。

4. 状态管理结构清晰

根据 Redux Toolkit 推荐：

store
├── index.ts
└── slices
├── user.ts
├── global.ts
└── xxx.ts

这样业务增长时不会造成状态混乱。

⚙️ 三、工程化体系（企业级必备）

1. GitLab CI 流水线

.gitlab-ci.yml 存在意味着：

push → 自动 lint + test

merge request → 自动构建

主干 → 自动发布（可能）

体现团队正规流程。

2. Makefile

一般包含：

make install
make dev
make build
make lint
make clean

意味着构建命令可统一标准化 → 适合跨平台 CI。

3. ESLint + Stylelint + CSpell

质量体系完整：

代码符合规范（避免低级错误）

风格统一（便于团队协作）

拼写检查（避免变量名出现 o/l/0 差错）

🚀 四、性能优化策略（可从负责人角度给出）

1. 构建体积优化

使用 Antd 时按需引入

动态 import + React.lazy 分割路由级 chunk

开启 gzip/br 压缩（部署层处理）

2. 运行时性能优化

表格等大数据量页面需 useMemo/useCallback 缓存

Redux 切分 slice，避免全局 re-render

📦 五、部署架构

项目使用 CRA + CRACO，最终构建为：静态资源（JS/CSS/HTML）

部署方式可能是：

Nginx 静态托管

上传到 object storage（OSS、S3）

GitLab Pages

或作为 Docker 镜像发布（取决于 CI 配置）

从 proxy: http://47.84.106.18:8190/ 可知本地开发需代理后端 API。

🎯 六、作为前端负责人可总结的价值

1. 技术选型稳定、成熟、易招人

React + Redux Toolkit + Antd 是中后台项目的最佳组合。

2. 注重工程化

CI、代码规范、Makefile、构建配置都体现工程化能力。

3. 架构清晰、扩展性强

前端分层合理，后期新增模块成本低。

4. 团队协作友好

约束强、规范清晰，适合多成员多模块迭代。

---

🧭 一、当时的技术选型对比：RTK vs Zustand vs Jotai
✅ 1. Redux Toolkit（最终选型）

适用场景：中大型项目、多团队协作、需要强约束的全局状态管理

优点：

状态流 predictable（可预测）

DevTools 强大（time-travel、action trace、state diff）

Redux Toolkit 大幅简化模板代码

非常适合登录态、权限、菜单、全局设置、表格筛选条件这些“强一致性状态”

缺点：

学习成本稍高

API 复杂度比 Zustand/Jotai 高

适配本项目？
✔ 业务多页面
✔ 全局状态较复杂（用户信息、权限、全局配置）
✔ 多人协作 + 企业级维护

⚪ 2. Zustand（未选型）

轻量、简单、现代。适合中小型项目。

优点：

API 极简

无样板代码

性能优异（浅比较、按片段订阅）

Hooks 风格天然友好

缺点：

没有“官方标准实践”（团队使用不统一）

缺少 middleware 生态（复杂业务逻辑需要自行实现）

状态结构不规范，多人协作容易写乱（尤其是没有清晰 slice 规范时）

DevTools/Time-Travel 能力不如 Redux

适配本项目？
⚠ 状态多 → 需要严格的约束
⚠ 团队新人参与多 → 需要成熟的最佳实践
⚠ 项目生命周期长 → Zustand 社区不如 Redux 稳定

→ 所以 Zustand 更适合 POC、小型独立模块，而不是核心前台管理系统。

⚪ 3. Jotai（未选型）

更适合组件级状态组合型场景。

优点：

原子化状态（哲学类似 Recoil）

组合能力强，适合高度组件化场景

轻量、现代化

缺点：

状态过多时难以管理（“原子爆炸问题”）

中台业务常见的“共享状态”无法很优雅解决

没有成熟的官方架构体系

难以统一跨团队的编码规范

适配本项目？
⚠ 本项目更需要 predictable state，而不是灵活多原子
⚠ 权限、角色、菜单、表格筛选等状态在 Jotai 下可能更难维护

📌 二、为什么最终是 RTK？（从“当时的背景”回答）

以下从**决策层视角（负责人视角）**说明：

1. 🏢 企业级项目需要更强的可控性和规范性

Redux 的单一数据流与严格状态流转，让任何开发者都能：

理解状态从哪来，被哪些 action 更新

如何追踪错误

对于 多人协作、多人维护 的中后台系统来说，这是关键。

Zustand/Jotai 灵活度高，但越灵活越容易在不同开发者手中被写成不同风格，长期维护成本变高。

2. 👥 团队人员梯度与技术背景的考虑

当时团队包含：

初级工程师

外包参与

实习生

RTK 具有：

统一标准

官方规范

强约束的数据流

相比之下：

Zustand → 太自由，容易写出不可维护代码
Jotai → 思维方式变化大，新手不易掌握原子流理念

从团队管理角度，RTK 更“可控”。

3. 📈 项目未来演进预期：状态会持续增加

本项目属于典型中后台系统，随着时间会出现：

多角色权限

菜单动态渲染

多 tab 页签缓存

全局设置

用户数据缓存

多表格筛选统一存储

WebSocket 全局数据

长期看，状态会越来越多，而 Redux 的 slice 化组织方式非常适合“逐步扩展”。

Zustand / Jotai 在状态多时不够结构化。

4. 🔧 RTK Query 的潜在使用价值

即便当时没有使用 RTK Query，未来也能引入：

Server State 管理

内置缓存、请求合并、轮询

自动加载状态（loading、error）

这其实是 React Query 的替代方案，但 RTK + RTKQ 的一致性更高，更适合企业项目。

Zustand / Jotai 则在这方面没有官方统一方案。

5. 🔬 调试工具和可观测性（Observability）非常重要

Redux DevTools 强大到是企业级项目的标配：

状态快照

时间回溯（time travel）

action 日志

state diff

管理系统调试复杂，比如：

权限没刷出来

多个筛选条件互相影响

某个全局参数导致渲染异常

Redux DevTools 能节省大量调试成本，而 Zustand/Jotai 的 DevTools 生态不如 Redux 稳定。

6. 🧱 生态成熟度、社区规模、文档质量

从企业视角：

Redux 是 React 官方推荐的全局状态管理

超大社区、成熟生态、优秀文档

大量解决方案可直接使用（presist 存储、immer、thunk、saga 等）

Zustand/Jotai 还处于趋势性技术（很优秀，但相对年轻）。

企业项目需要“可持续 5+ 年的稳定性”。

🎯 三、总结一句话（可用于会议/文档）

最终选择 Redux Toolkit，是因为它在强规范、多团队协作、长期可维护性、调试能力、生态成熟度上的优势，更符合一个企业级中后台系统的工程目标。

Zustand / Jotai 更轻量，但灵活度带来的不一致性，会让大型项目在中后期出现明显维护成本。

如今，RTK 已成为编写 Redux 逻辑的标准方式。如同所有工具一样，它也有其优缺点。RTK 的代码量可能比 Zustand 略多，但它也提供了将应用逻辑与 UI 分离的实用模式。Redux 并非适用于所有应用，但它仍然是 React 应用中最广泛使用的状态管理库，拥有优秀的文档，并提供大量功能来帮助您构建结构一致且可预测的应用。

---

🧩 一、项目规模与生命周期的考量（Project Scope & Life Cycle）

我们预期项目将：

长期迭代（> 1 年周期）

功能模块会不断扩展

团队成员人数会增加且成分复杂（正式/外包/新人）

因此技术必须满足：

易扩展性（模块增长不增加复杂度）

可维护性（多人协作不会失控）

稳定性（不选实验性技术）

这就要求我们选择社区成熟的解决方案，而不是趋势性的库。

🏢 二、团队技术结构与 Onboarding 成本

技术选型最重要的不是“技术本身”，而是：

团队是否能用好？新人是否能快速上手？未来是否能轻松招聘？

当时团队情况大致如下：

React 经验：普遍具备

Redux：大部分人熟悉

Zustand/Jotai：只有少量成员接触

因此：

React + Redux Toolkit → 最高团队一致性

Ant Design → 新人几小时就能上手

从负责人角度，最重要的是：

“选一个十个新人进来，九个不会写歪的方案。”

🔧 三、生态成熟度（Ecosystem Maturity）

我们需要的是一个 “不需要踩坑就能闭着眼用” 的生态。

技术选型时主要评估：

技术点 是否成熟 是否持续维护 生态完善度
React ⭐⭐⭐⭐⭐ 是 极强
Redux Toolkit ⭐⭐⭐⭐⭐ 是 极强
Zustand ⭐⭐⭐⭐ 是 中等
Jotai ⭐⭐⭐ 是 中等偏低
Ant Design ⭐⭐⭐⭐⭐ 是 超强
Vite 彼时生态尚未完全成熟（尤其是兼容 CRA 插件） 部分 不稳定
Tailwind 适合业务逻辑少的项目 但团队经验不足 弱一些

最终，我们选的都是：

有大厂背书

有长期维护

更容易从社区找到现成解决方案

这直接降低长期维护风险。

📈 四、性能与架构可控性（Performance & Architecture Risks）

我们并不仅仅关注“跑快不快”，而是：

渲染性能是否容易掉入坑

状态是否容易导致多余渲染

是否有成熟的性能监控工具

数据层是否可以可控扩展

举例：

React + Redux Toolkit

数据流严格 → 不容易出现意外的 re-render

有工具（Reselect、RTK Query）可以优化

状态行为可预测（Predictable State）

Zustand

性能很好

但因为太自由：
→ 很容易写出导致隐藏渲染的“坏模式”

Jotai

原子依赖关系复杂

多原子组合时的性能不可控

大型页面更容易踩坑

因此从风险控制角度，RTK 仍更稳。

🧱 五、工程化体系的可扩展性（Engineering System）

当时项目需要：

CI/CD 集成（GitLab）

规范的 lint + format

国际化能力

复杂路由管理

统一的接口层

样式体系（Less）

这些功能都要求：

技术栈必须具备强工程化能力，且高度可配置。

CRA + CRACO 完全满足。
Vite 当时在企业级插件生态不如现在成熟。

另外：

Redux 在大型项目的工程化管理（slice、middleware、store、selector）远比 Zustand/Jotai 更体系化。

Antd + Less 生态配合更成熟（高度契合 CRACO）

🧪 六、质量保障（Quality Gate）

技术选型时，我们需要保证：

可测试性

可调试性

可回溯性（state diff）

可观测性（Observability）

Redux Toolkit 直接满足：

Redux DevTools：完整时序记录

中间件（middleware）的 hook 能力强

单元测试难度低

Zustand/Jotai 在大型系统的可测试性较弱，调试工具不完备。

🧯 七、未来功能规划预留（Future Proofing）

我们在技术选型时考虑到未来会增加：

缓存请求（Cache Layer）

轮询数据

WebSocket 实时数据

表格分页/筛选持久化

用户配置持久化

多 Tab 页签缓存

这些都要求：

状态管理能力必须远不止“存点数据”。

RTK / RTK Query 在这些场景都有成熟方案。

Zustand / Jotai 则需要自行搭建，维护成本更高。

🎯 八、总结：除了性能和流行度，我们更关注“企业级项目的长期成功率”
所以当时做技术选型时我们重点关注的是：

团队是否能快速上手？

五年后代码是否仍可维护？

是否足够可控？是否可观测？是否可测试？

是否能承载未来的复杂需求？

CI/CD、工程化体系能否轻松接入？

风险是否最低？替换成本是否高？

最终我们选择的技术栈：

不是最潮的，也不是最轻量的，而是“对项目、对团队、对业务最稳妥的”。

---

🧱 一、代码质量保证体系的整体框架

我们采用标准的 四层代码质量体系：

编码规范 → 工具自动校验 → CI 阶段阻断 → 代码评审 → 线上监控

这是大厂前端团队通用模式。

🧩 二、编码规范（Coding Standards）

1. 统一的项目规范手册

我们编写了内部文档，包含：

文件命名规范（kebab-case / PascalCase）

目录结构规范（api/store/pages/components）

Hook 的使用规范（何时 useMemo/useCallback）

React 组件规范（受控组件、props 约束）

Redux 状态组织规范（slice、selector）

样式规范（BEM、Less 变量、禁止深层嵌套）

确保所有开发者有一致的行为准则。

🧰 三、工具层质量保障（自动化代码检测）

项目中能看到一些关键配置：

ESLint

Stylelint

Prettier

CSpell

Husky + lint-staged

TypeScript + tsconfig 严格模式

这些工具组成了第一道质量防线。

1. ESLint（语法检查 + 规范约束）

我们启用了：

eslint-config-airbnb 或 eslint-config-react-app

eslint-plugin-react-hooks

eslint-plugin-import

eslint-plugin-jsx-a11y（可访问性检查）

目的：

✔ 提前发现潜在 bug
✔ 强制统一的写法标准
✔ 消除团队间风格差异
✔ 避免业务逻辑错误或死循环
✔ 避免 useEffect 使用不当

2. TypeScript 严格模式

我们启用：

"strict": true,
"noImplicitAny": true,
"strictNullChecks": true

目的：

✔ 避免空值导致的运行时异常
✔ 确保 API 类型稳定
✔ 组件 props 有完整类型保护
✔ 自动补全提升开发效率

3. Stylelint（样式检查）

目的：

✔ 避免不规范的选择器
✔ 避免多层嵌套（减少性能问题）
✔ 保持统一风格
✔ 避免魔法数字

4. CSpell（拼写检查）

cspell 能捕捉：

变量名拼写错误

类型名拼写错误

API 字段拼写错误

在多人协作中非常关键。

5. Husky + lint-staged（提交前检查）

在 git commit 阶段：

禁止提交 ESLint 失败的代码

禁止提交 Stylelint 失败的样式

自动 Prettier 格式化

自动 CSpell 检查

确保“脏代码没法被提交”。

🧨 四、流程质量保障（Code Review + MR 流程）

Code Review 是保证质量最重要的手段之一，并且是强制执行。

Code Review 包含：

1. 代码逻辑是否正确

包括边界条件、空判断、潜在数据错误。

2. 是否遵循 React 最佳实践

useEffect 是否正确依赖

组件是否拆分合理

状态是否合理分层（local state / global state）

3. 是否符合团队架构规范

API 是否统一封装

Redux 是否按 slice 划分

工具函数是否放入 utils

组件文件夹结构是否规范

4. 性能问题

大表格是否 memo

大量 DOM 是否 virtualize

是否引入不必要的第三方包

5. 安全问题

XSS 处理

参数校验

接口 token 使用是否安全

🔁 五、CI/CD 阶段的强制质量关卡（Pipeline Blocking）

基于 GitLab CI，我们做了如下阻断流程：

lint → test → build → 审核 → 部署

具体包括：

1. Lint 阶段（阻断）

eslint --max-warnings=0

stylelint

cspell

tsx 构建检查

任何 warning 都阻断 MR。

2. 自动测试（如有配置）

Jest 单测

关键功能端到端测试（E2E）

3. 构建环境检查

依赖问题（npm audit）

构建性能数据（构建体积、bundle 分析）

所有步骤不通过 → 禁止合并。

这叫“强制质量门控（Quality Gate）”，是企业级项目的标配。

🧪 六、运行期质量控制（线上质量保障）

我们使用：

Sentry（错误监控）

Web Vitals（性能监控）

日志上报（API 失败、关键操作）

用户行为埋点（便于复现问题）

目的：

避免线上问题发生后难以定位

从用户报错中反推代码质量问题

这些监控是质量体系的最后一环。

🏁 七、开发文化与惯例（最容易被忽视但最重要）

我们强调：

1. “警告视为错误”

所有 warning 都需要清零。

2. “小 PR 原则”

每次提交保持可 review、可回滚、可定位。

3. “先设计再编码”

复杂需求要求先产出架构图、API 设计、状态设计。

4. “组件可复用优先”

避免重复造轮子 → 提升项目整体质量。

🎯 最终总结：我们是如何保证代码质量的？

一句话：

通过 规范、工具链、流程、自动化、监控、团队文化 六位一体，使代码质量不会依赖个人，而是由团队机制自动保证。

这是一套完整、可复制、可扩展的“企业级代码质量体系”。

---
