# 组件库项目(一)

## 项目背景

公司计划对 DMP 项目中老旧但核心的业务页面进行整体迁移和重构，并采用最新的设计规范统一产品风格。为提升整体可维护性与产品线的 UI 一致性，需要将项目中可复用的组件与业务通用逻辑抽离出来，构建为独立的组件库，并以第三方 npm 包的形式提供给业务项目使用。

## 技术选型

- React:作为核心 UI 框架，构建组件化体系，提高可复用性与可维护性
- TypeScript:提供强类型约束，确保组件 API 的稳定性与可扩展性，同时提升开发体验
- Ant Design:作为基础组件进行二次封装
- Rollup:用于构建组件库，支持多格式输出（ESM/CJS/Umd），优化产物体积与 tree-shaking 效果
- 代码质量：eslint、prettier,cSpell，stylelint
- 部署：verdaccio

### 追问 1：为什么选择了 RollUp 作为构建工具，是否考虑过其他构建工具

做过 Webpack、Vite 等工具的对比后，最终选择 Rollup，因为它对库构建场景更友好，产物体积更小，tree-shaking 也更彻底，同时能灵活输出 ESM/CJS/UMD 多种格式，这些特性更符合组件库的核心诉求。而且对于多包场景，每个包都可以有自己独立的配置文件，也更好维护。

### 追问 2：你在 rollup 做了哪些配置

首先是通过数组支持多格式输出(ESM / CJS / DTS)；

然后是外部依赖管理，通过 externalPackages 将核心依赖如 React 等标记为外部依赖，同时使用 `rollup-plugin-peer-deps-external` 插件的 `peerDepsExternal({ includeDependencies: true })`方法将 package.json 中的 peerDependencies 以及可选的 dependencies 也视为外部依赖，这些依赖不会打包进最终的 bundle 中，而是让业务项目去自己安装。这样既保证了库的小体积，也避免了组件库和业务项目的依赖版本冲突。

其次为了支持 monorepo 多包结构，每个包下面都有自己的 src 目录，通过工具函数扫描每个子目录得到模块列表，每个子目录对应一个功能模块，并自动寻找 index.ts 或 index.tsx 文件作为模块入口，使得每个模块都可以独立构建，方便后续按需发布和引入。

最后还有就是插件链条设计，首先用 peerDepsExternal 标记外部依赖；然后通过 resolve+commonjs 支持从 node_modules 引入依赖，将 CJS 模块转换为 ESM；接着`rollup-plugin-typescript2`插件的 typescript 方法将 TS 编译为 JS，同时生成类型声明文件`.d.ts`。然后通过`@rollup/plugin-babel`提供的 babel 提供向下兼容能力；借助 postcss+autoprefixer+cssnano 支持 Less、CSS Modules，防止样式冲突，压缩样式，单独抽取 css,方便按需加载；最后通过 image 支持图片导入以及 clear 在构建前清理目录，保证输出干净。

## 项目架构

组件库整体采用了 pnpm workspace 和 monorepo 架构，将不同的功能模块拆分为独立的 package，每个 package 独立构建和发版。主要分成四个 package,其中 ui 包依赖于 hooks 和 utils，而 ui-business 包依赖于 ui 包:

1. hooks:通用的自定义 hooks
2. utils:工具函数库
3. ui:基于 antd 封装的基础 UI 组件，比如权限按钮 PermissionButton
4. ui-business:和业务绑定较深的定制组件，比如修改所有者 TransferOwnerModal

### 追问 1：为什么选择 monorepo 架构

1. 各个包之间开发调试更加容易，使用软链接，不需要频繁 npm link。
2. 依赖版本一致性更好控制，避免多包版本不一致。
3. 统一规范统一构建流程，所有包复用同一套 ESLint、基础 TSConfig
4. 跨包修改更简单，一个 PR 可以同时修改多个包，无需分仓库管理

### 追问 2：为什么选择了 pnpm workspace

因为组件库内部由多个子模块组成，它们之间可能存在依赖关系,比如业务组件库 dmp-business-ui 依赖通用组件库 dmp-ui。如果使用普通的 npm 安装，则每个包都会把依赖的模块安装一份到 node_modules,造成磁盘占用以及版本冲突管理。

而 pnpm workspace 让包之间依赖以软链接方式存在，比如 business-ui 依赖 ui，pnpm 不会复制 ui 到 business-ui/node_modules，而是创建一个软连接指向根目录的`node_modules/.pnpm/ui@x.y.z/node_modules/ui`,语法是`"@actiontech/dmp-hooks": "workspace:^"`
最终所有包都共享同一个 ui 的实际文件。

这样可以避免重复安装依赖，节省空间，同时保证依赖版本统一，另外一方面，修改 ui 的源码，business-ui 立刻就可以使用最新修改。

## 组件库发布

1. 进入对应的子包进行打包，打包后的产物应该包括 es，lib 文件夹
2. 修改子包 package.json 文件中的 version
3. 登录到私有源，将终端位置切换到需要发包的文件夹，执行`pnpm publish`

### 追问 1：你们的版本管理是手动的吗

目前团队规模较小，且组件库的变更都需要经过团队成员 code-review 才能合并到主分支进行发布，而且公司希望尽快将组件库应用到业务项目迁移上，所以暂时采用了手动方式。但后续迁移完成后，个人认为可以采用自动化版本管理，比如使用 changeset 自动管理版本+变更日志。

```bash
pnpm add -D @changesets/cli
pnpm changeset
```

### 追问 2：版本采用什么形式

版本管理依据 SemVer：

- patch：bug fix
- minor：新增组件或功能
- major：BREAKING CHANGES

## 组件库如何保证类型声明的正确性

首先所有组件使用 TypeScript 编写，利用 Rollup + rollup-plugin-dts 输出类型文件；其次将类型统一维护在 types 模块；业务组件对 UI 组件做类型二次增强，这样业务开发者能享受到自动推导和类型提示。

## 判断是否应该将一个需求沉入组件库

| 指标   | 问题                     | 评分权重   |
| ------ | ------------------------ | ---------- |
| 复用性 | 多个项目会用到吗？       | ⭐⭐⭐⭐⭐ |
| 通用性 | 能抽象成稳定 API 吗？    | ⭐⭐⭐⭐   |
| 稳定性 | 需求是否成熟稳定？       | ⭐⭐⭐     |
| 复杂度 | 对业务是否是高成本功能？ | ⭐⭐⭐⭐   |
| 规范性 | 是否有助于统一体验？     | ⭐⭐⭐     |

## 遇到过的难题

### 问题 1：组件库里处理 CSS 隔离

采用了三层隔离策略：

1. 命名空间隔离：所有组件最外层都加前缀，杜绝和业务代码、AntD 样式冲突
2. 采用 CSS Modules/Less Module 模块化
3. 采用 BEM 命名方式，比如：`.dmp-ui-button__icon`

### 问题 2：声明文件冲突

我们会借助 rollup 和插件 rollup-plugin-dts 自动生成类型声明，但是如果组件内本身有这个定义文件，则会发生冲突；我们需要将组件内的名称替换为`index.type.d.ts`，避免打包冲突

## 印象最深的一个组件和自定义 Hooks

### PermissionButton 组件

在 B 端项目中，列表的顶部或者操作列需要隐藏没有权限的操作按钮，所以需要封装一个 PermissionButton 组件，同时在此基础上开发出 PermissionButtonGroup 等衍生组件。

### usePermission

在列表页中统一处理“权限按钮”的获取、合并、状态初始化等逻辑，让 UI 组件只关注渲染而不用关心权限结构和异步请求。

## 国际化

## 主题切换
