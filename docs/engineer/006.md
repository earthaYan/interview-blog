# 代码分割

原因：方便项目更快打开

- 单入口：所有代码在一个文件里，导致代码过大，所以需要把一些不是立刻用到的代码拆分出来异步加载，从而加快首屏速度

```js
setTimeout(() => {
  import(/*webpackChunkName:"APP"*/ "./app.tsx").then((res) => {
    console.log(res, res.a);
  });
}, 2000);
```

- 多入口：主要问题是重复加载同一段逻辑代码

```js
module.exports = {
  optimization: {
    splitChunks: {
      // 分割规则 all/async只拆分异步/initial只拆分同步
      chunks: "all",
      // 重复出现超过n次则进行拆分
      minChunks: 2,
      // 重复文件大于这个值才进行拆分
      minSize: 1000, //1000byte
    },
  },
};
```

## 第三方库独立打包

产物：`vendor.js`,`runtime.js`

问题：多入口的情况下，两个入口文件引入了多个相同的依赖，那么这些依赖都会打包到一个 js 中，第三方库和工具也会打包到一起，所以需要把这些单独打包出来

最终配置：

```js
module.exports = {
  optimization: {
    splitChunks: {
      // 分割规则 all/async只拆分异步/initial只拆分同步
      chunks: "all",
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          filename: "vendor.js",
          chunks: "all",
          minChunks: 1,
        },
        // 公用文件
        common: {
          filename: "common.js",
          chunks: "all",
          minChunks: 2,
          minSize: 0,
        },
      },
    },
    //webpack运行时代码打包
    runtimeChunk: {
      name: "runtime",
    },
  },
};
```

## 非代码分割

## resolve

- alias:提供路径简写
- extensions：扩展省略，定义可省略的扩展名

```js
module.exports = {
  resolve: {
    //路径别名
    alias: {
      "@css": "/css",
      "@img": "/imgs",
    },
    // import文件的时候可以省略后缀
    extensions: [".js", ".css"],
  },
};
```

## 打包后的资源分类
