# css 和资源文件的处理

js 中引入 css 一定会打包失败，原因是 webpack 本身无法失败 css，所以需要 css-loader 让 webpack 识别出 css

## css

- css-loader:让 webpack 识别 css，**下一步**有以下两种方式，但通常选择第二种：

  - style-loader:把 css 写入 js，执行后作为 style 标签插入 html
  - mini-css-extract-plugin:提取 css 为独立文件

```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ["style-loader", "css-loader"],
      },
      {
        test: /\.less$/,
        use: [MiniCssExtractPlugin.loader, "css-loader", "less-loader"],
      },
    ],
  },
  plugins: [
    new eslintPlugin(),
    new MiniCssExtractPlugin({
      filename: "[name].[hash:4].bundle.css",
    }),
  ],
};
```

## 压缩 css

安装插件`css-minimizer-webpack-plugin`

```js
const cssMinimizerPlugin = require("css-minimizer-webpack-plugin");
module.exports = {
  plugins: [new cssMinimizerPlugin()],
};
```

## 其他资源处理

js/css 文件中引入了其他类型的资源，

- webpack4 需要 file-loader 和 url-loader 处理;url-loader 基于 file-loader 加了一些优化操作
- webpack5 自带对资源文件的支持

::: code-group

```js [webpack4]
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|jpeg|gif|svg)$/,
        use: [
          {
            loader: "url-loader",
            options: {
              // 小于这个限制则转为base64
              limit: 1000,
              name: "[name].[contenthash:4].[ext]",
            },
          },
        ],
      },
    ],
  },
};
```

```js [webpack5]
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|jpeg|gif|svg)$/,
        type: "asset",
        parser: {
          dataUrlCondition: {
            // 小于120kb则转换为base64,否则提取为单独资源
            maxSize: 120 * 1024,
          },
        },
        generator: {
          filename: "img/[name].[contenthash:4].[ext]",
        },
      },
    ],
  },
};
```

:::
