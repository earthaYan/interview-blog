# rollup

## 特点：

1. 不会生成过多的运行代码
2. 可以多模块化规范代码

## 核心配置

```js
module.exports = {
  input,
  output: {
    dir,
    file,
    format, //必须，输出的模块化
  },
  external,
  plugins,
};
```

## 打包后产物内容没有 import 的模块

`import f1 from "mode1.js";`

如果导入没有写相对路径名或者绝对路径名，rollup 会认为这是裸模块名(node_modules 中的第三方包或者 externals 依赖)

## 外部依赖和插件

- plugins:打包第三方库
- external:不打包进 bundle 的外部依赖

```js
const pluginNodeResolve = require("@rollup/plugin-node-resolve");
const terser = require("@rollup/plugin-terser");
module.exports = {
    external：["lodash-es"],
    //第三方插件：打包第三方库并压缩所有打包后的代码
    plugins: [pluginNodeResolve(), terser()],
};
```

## vite

Vite 在**开发阶段**利用浏览器原生 ES Module 能力，不进行全量打包，而是按需编译、加载模块；相比 Webpack 启动时需要分析所有模块、构建完整依赖图并进行全量编译，Vite 仅在模块被请求时才进行处理，从而显著提升了冷启动速度。

Vite 的 HMR 是基于 ESM 模块粒度的，修改单个文件只重新编译该模块；而 Webpack 的 HMR 基于 bundle，修改某个文件需要重新构建对应模块及依赖，刷新速度受 bundle 大小影响，Vite 相对于 webpack，热更新速度显著提升。

同时 vite 配置相对简单，不需要大量的 loader，webpack 配置相对比较复杂

生产环境构建方面，vite 底层用的是 rollup，本身对 ESM 支持完美，Tree Shaking 和代码分割更精准。开发阶段直接使用 ES Module，天然支持模块化、按需加载；Webpack 不依赖浏览器原生的模块机制，而是通过打包和运行时代码来实现模块化和按需加载
