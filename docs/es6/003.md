# Promise 和 async 函数

## 异步

因为 JS 可以修改 DOM 结构，所以 JS 和 DOM 渲染只能共用一个线程，所以 JS 被设计为单线程语言（同一时间只能执行一个任务）。

但带来的问题是某个任务（例如网络请求、定时器或文件读取）耗时很长，就会阻塞整个线程，导致页面卡死、无法响应用户操作，所以出现了基于回调函数实现的异步机制(事件循环)。

无限嵌套的回调函数带来了 callback hell 的问题，为了解决这个问题，promise 出现了。

## promise

将 callback 的形式从嵌套变成了管道形式（非嵌套），可以进行链式调用。

### promise 加载图片

如何解决回调地狱示例

```javascript
function loadImg(src) {
  return new Promise((resolve, reject) => {
    const img = document.createElement("img");
    img.onload = () => {
      resolve(img);
    };
    img.onerror = () => {
      reject("加载图片失败");
    };
    img.src = src;
  });
}
//非嵌套式调用
loadImg(url1)
  .then((img) => {
    console.log(img.width);
    return img; //返回普通对象
  })
  .then((img) => {
    console.log(img.height);
    return loadImg(url2); //返回promise对象
  })
  .then((img2) => {
    console.log(img2.width);
  });
```

### then/catch

then/catch 回调函数默认都返回 resolved 状态的 promise,如果有报错比如 throw error 则返回 rejected 状态的 promise;

如果返回了一个整数，则表示 resolved 回来的值是这个整数。

```javascript
Promise.resolve()
  .then(() => {
    console.log("resolve1");
    return { a: 100 };
  })
  .then((res) => {
    console.log("resolve2", res); //{a:100}
  })
  .then((res) => {
    console.log(res); //undefined
  });
```

## async await

优势：promise 基于回调函数，而 async await 是同步语法，彻底消灭了回调函数

特点：

1. async 函数默认返回 Promise 对象，如果返回的是原始类型值，相当于返回 Promise.resolve(xx)
2. await 相当于 Promise.then，await 后面的所有内容都可以看作是回调函数的内容(异步)
3. 使用 try...catch 捕获异常

```javascript {3}
async function async1() {
  console.log("async1 start"); //2
  await async2();
  // 下面的为异步代码
  console.log("async1 end"); //5
}
async function async2() {
  console.log("async2"); //3
}
console.log("script start"); //1
async1();
console.log("script end"); //4
```

上述代码中，高亮部分会先执行 async2,再执行 await,await 后面的代码都是异步代码

```js
async function fn() {
  return 100;
}

!(async function () {
  const a = fn();
  const b = await fn();
  console.log(a); //a为resolved状态的promise对象
  console.log(b); //b为100
})();
```

## 事件循环

JavaScript 是单线程的，为了同时处理异步任务，引入了事件循环机制。

整个执行过程是这样的：

1. 同步代码会在主线程中按顺序执行，这些代码进入调用栈（Call Stack）。
2. 当遇到异步任务，比如 setTimeout 或 Promise.then 时，JS 引擎不会立即执行它们，而是交给宿主环境（浏览器）处理。
3. 等异步任务准备好后，浏览器会把它们的回调函数分别放入不同的任务队列
4. 当主线程的同步任务执行完、调用栈清空后，事件循环就会先检查微任务队列，把里面的所有微任务一次性执行完。
5. 微任务清空之后，浏览器会在这时机会上进行一次 DOM 渲染（如果有更新）
6. 事件循环从宏任务队列中取出一个任务放入调用栈，执行它的同步代码，再进入下一轮循环

一句话总结：

“一次事件循环包括：执行一个宏任务 → 执行所有微任务 → （可能）触发渲染 → 再进入下一轮宏任务。”

### 微任务 vs 宏任务

call stack 空闲，DOM 会尝试渲染变更后的 DOM 结构。渲染完成后才会触发下一次的 event loop。

- 微任务：Promise,async...await,MutationObserver
- 宏任务：setTimeout,setInterval,ajax 请求,DOM 事件

> 执行时机：微任务比宏任务早执行

## 手写 promise

核心功能：

1. 初始化和异步调用
2. then/catch 链式调用
3. 核心 api：resolve,reject,all,race

::: code-group

```js [构造函数]
class MyPromise {
  state = "pending";
  value;
  reason;
  resolveCallbacks = []; //pending状态下存储成功的回调
  rejectedCallbacks = []; //pending状态下存储失败的回调

  constructor(fn) {
    const resolveHandler = (value) => {
      if (this.state === "pending") {
        this.state = "fulfilled";
        this.value = value;
        this.resolveCallbacks.forEach((fn) => fn(this.value));
      }
    };
    const rejectHandler = (reason) => {
      if (this.state === "pending") {
        this.state = "rejected";
        this.reason = reason;
        this.rejectedCallbacks.forEach((fn) => fn(this.reason));
      }
    };

    try {
      fn(resolveHandler, rejectHandler);
    } catch (err) {
      rejectHandler(err);
    }
  }
}
```

```js [then实现]
class MyPromise {
  then(fn1, fn2) {
    //当pending状态下，fn1,fn2会被存储到两个callbacks数组中
    fn1 = typeof fn1 === "function" ? fn1 : (v) => v;
    fn2 = typeof fn2 === "function" ? fn2 : (e) => e;

    if (this.state === "pending") {
      return new MyPromise((resolve, reject) => {
        this.resolveCallbacks.push(() => {
          try {
            const newValue = fn1(this.value);
            resolve(newValue);
          } catch (err) {
            reject(err);
          }
        });
        this.rejectCallbacks.push(() => {
          try {
            const newReason = fn2(this.reason);
            reject(newReason);
          } catch (err) {
            reject(err);
          }
        });
      });
    }
    if (this.state === "fulfilled") {
      return new MyPromise((resolve, reject) => {
        try {
          const newValue = fn1(this.value);
          resolve(newValue);
        } catch (err) {
          reject(err);
        }
      });
    }
    if (this.state === "rejected") {
      return new MyPromise((resolve, reject) => {
        try {
          const newReason = fn2(this.reason);
          reject(newReason);
        } catch (err) {
          reject(err);
        }
      });
    }
  }
  catch(fn) {
    return this.then(null, fn);
  }
}
```

```js [全局api]
MyPromise.resolve = (value) => {
  return new MyPromise((resolve, reject) => resolve(value));
};
MyPromise.reject = (reason) => {
  return new MyPromise((resolve, reject) => reject(reason));
};
MyPromise.all = (promiseList = []) => {
  return new MyPromise((resolve, reject) => {
    const result = [];
    const len = promiseList.length;
    let resolveCount = 0;

    promiseList.forEach((p) => {
      p.then((data) => {
        result.push(data);
        resolveCount++;
        if (resolveCount === len) {
          resolve(data);
        }
      }).catch((err) => {
        reject(err);
      });
    });
  });
};
MyPromise.race = (promiseList = []) => {
  let resolved = false;
  return new MyPromise((resolve, reject) => {
    promiseList.forEach((p) => {
      p.then((data) => {
        if (!resolved) {
          resolve(data);
          resolved = true;
        }
      }).catch((err) => {
        reject(err);
      });
    });
  });
};
```

:::
