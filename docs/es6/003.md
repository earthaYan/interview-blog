# Promise 和 async 函数

## 异步

因为 JS 可以修改 DOM 结构，所以 JS 和 DOM 渲染只能共用一个线程，所以 JS 被设计为单线程语言（同一时间只能执行一个任务）。

但带来的问题是某个任务（例如网络请求、定时器或文件读取）耗时很长，就会阻塞整个线程，导致页面卡死、无法响应用户操作，所以出现了基于回调函数实现的异步机制(事件循环)。

无限嵌套的回调函数带来了 callback hell 的问题，为了解决这个问题，promise 出现了。

## promise

将 callback 的形式从嵌套变成了管道形式（非嵌套），可以进行链式调用。

### promise 加载图片

如何解决回调地狱示例

```javascript
function loadImg(src) {
  return new Promise((resolve, reject) => {
    const img = document.createElement("img");
    img.onload = () => {
      resolve(img);
    };
    img.onerror = () => {
      reject("加载图片失败");
    };
    img.src = src;
  });
}
//非嵌套式调用
loadImg(url1)
  .then((img) => {
    console.log(img.width);
    return img; //返回普通对象
  })
  .then((img) => {
    console.log(img.height);
    return loadImg(url2); //返回promise对象
  })
  .then((img2) => {
    console.log(img2.width);
  });
```

### then/catch

then/catch 回调函数默认都返回 resolved 状态的 promise,如果有报错比如 throw error 则返回 rejected 状态的 promise;

如果返回了一个整数，则表示 resolved 回来的值是这个整数。

```javascript
Promise.resolve()
  .then(() => {
    console.log("resolve1");
    return { a: 100 };
  })
  .then((res) => {
    console.log("resolve2", res); //{a:100}
  })
  .then((res) => {
    console.log(res); //undefined
  });
```

## async await

promise 还是基于回调函数，而 async await 是同步语法，彻底避开了回调函数

## 事件循环

参与者：browser console,call stack,web apis,callback queue

1. 同步代码放到 call stack 逐行执行
2. 遇到异步代码，记录下，等待时机
3. 时机到了，移动回调函数到 callback queue
4. call stack 空(同步代码执行完成),event loop 开始工作
5. 轮询 callback queue,有则移动到 call stack 执行，没有则继续使用轮询查找
