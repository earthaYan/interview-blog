---
outline: deep
---

# Promise 和 async 函数

## 事件循环

JavaScript 是单线程的，为了同时处理异步任务，引入了事件循环机制。

整个执行过程是这样的：

1. 同步代码会在主线程中按顺序执行，这些代码进入调用栈（Call Stack）。
2. 当遇到异步任务，比如 setTimeout 或 Promise.then 时，JS 引擎不会立即执行它们，而是交给宿主环境（浏览器）处理。
3. 等异步任务准备好后，浏览器会把它们的回调函数分别放入不同的任务队列
4. 当主线程的同步任务执行完、调用栈清空后，事件循环就会先检查微任务队列，把里面的所有微任务一次性执行完。
5. 微任务清空之后，浏览器会在这时机会上进行一次 DOM 渲染（如果有更新）
6. 事件循环从宏任务队列中取出一个任务放入调用栈，执行它的同步代码，再进入下一轮循环

### 微任务 vs 宏任务

call stack 空闲，DOM 会尝试渲染变更后的 DOM 结构。渲染完成后才会触发下一次的 event loop。

- 微任务：Promise,async...await,MutationObserver
- 宏任务：setTimeout,setInterval,ajax 请求,DOM 事件

> 执行时机：微任务比宏任务早执行

## node 事件循环和普通事件循环

微任务：`process.nextTick`>`promise.then`

> Node.js 的事件循环是由 libuv 驱动的多阶段模型，每个阶段执行特定类型的回调，并在阶段结束后优先清空 process.nextTick 和 Promise 微任务，以保证异步逻辑的高优先级执行。

### 阶段划分

1. timers 阶段：执行到期的 setTimeout、setInterval 回调。
2. pending callbacks 阶段：执行上一轮循环中遗留的微任务。
3. idle / prepare 阶段：内部使用，对开发者不可见。
4. poll 阶段（核心阶段）：执行 I/O 回调（如网络、文件读写）
5. 如果队列为空：有 setImmediate → 进入 check 阶段；没有 → 阻塞等待新的 I/O
6. check 阶段：执行 setImmediate 回调。
7. close callbacks 阶段：执行资源关闭相关的回调（如 socket.on('close')）。

## promise

将 callback 的形式从嵌套变成了管道形式（非嵌套），可以进行链式调用。

### promise 加载图片

如何解决回调地狱示例

```javascript
function loadImg(src) {
  return new Promise((resolve, reject) => {
    const img = document.createElement("img");
    img.onload = () => {
      resolve(img);
    };
    img.onerror = () => {
      reject("加载图片失败");
    };
    img.src = src;
  });
}
//非嵌套式调用
loadImg(url1)
  .then((img) => {
    console.log(img.width);
    return img; //返回普通对象
  })
  .then((img) => {
    console.log(img.height);
    return loadImg(url2); //返回promise对象
  });
```

### then/catch

then/catch 回调函数默认都返回 resolved 状态的 promise,如果有报错比如 throw error 则返回 rejected 状态的 promise;

如果返回了一个整数，则表示 resolved 回来的值是这个整数。

```javascript
Promise.resolve()
  .then(() => {
    console.log("resolve1");
    return { a: 100 };
  })
  .then((res) => {
    console.log("resolve2", res); //{a:100}
  })
  .then((res) => {
    console.log(res); //undefined
  });
```

## async await

优势：promise 基于回调函数，而 async await 是同步语法，彻底消灭了回调函数

特点：

1. async 函数默认返回 Promise 对象，如果返回的是原始类型值，相当于返回 Promise.resolve(xx)
2. await 相当于 Promise.then，await 后面的所有内容都可以看作是回调函数的内容(异步)
3. 使用 try...catch 捕获异常

```javascript {3}
async function async1() {
  console.log("async1 start"); //2
  await async2();
  // 下面的为异步代码
  console.log("async1 end"); //5
}
async function async2() {
  console.log("async2"); //3
}
console.log("script start"); //1
async1();
console.log("script end"); //4
```

上述代码中，高亮部分会先执行 async2,再执行 await,await 后面的代码都是异步代码

```js
async function fn() {
  return 100;
}

!(async function () {
  const a = fn();
  const b = await fn();
  console.log(a); //a为resolved状态的promise对象
  console.log(b); //b为100
})();
```

## promise A+规范

Promise 的核心可以总结为两件事：状态管理和 then 返回值解析。Promise 有三种状态：pending、fulfilled 和 rejected，状态不可逆。每次调用 then 都会返回一个新的 Promise，实现链式调用。then 回调的返回值决定下一个 Promise 的状态

- 普通值，则他返回的 promise 状态为 resolved 状态
- promise,则他返回的 promise 状态取决于 then 返回的 promise
- thenable 对象，则按照 promise 去解析
- 自身，为了避免循环引用这里会报 type error

## 手写 promise

核心功能：

1. 初始化和异步调用
2. then/catch 链式调用
3. 核心 api：resolve,reject,all,race

::: code-group

```js [构造函数]
class MyPromise() {
  constructor(executor){
    this.state='pending'
    this.value=undefined;
    this.reason=undefined;
    this.resolvedCbs=[]
    this.rejectedCbs=[]

    const resolve=(value)=>{
      if(value instanceof Promise){
        //如果 value 是一个promise，那我们的库中应该也要实现一个递归解析
        return value.then(resolve,reject)
      }
      if(this.state==='pending'){
        this.state='fulfilled'
        this.value=value
        this.resolvedCbs.forEach(fn=>fn())
      }
    }
    const reject=(reason)=>{
      if(this.state==='pending'){
        this.state='rejected'
        this.reason=reason
        this.rejectedCbs.forEach(fn=>fn())
      }
    }

    try{
      executor(resolve,reject)
    }catch(err){
      reject(err)
    }
  }
}
```

```js [then实现]
class MyPromise {
  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (v) => v;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (err) => {
            throw err;
          };
    let promise2 = new MyPromise((resolve, reject) => {
      if (this.state === "fulfilled") {
        queueMicroTask(() => {
          try {
            let x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      }

      if (this.state === "rejected") {
        queueMicroTask(() => {
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        });
      }

      if (this.state === "pending") {
        this.resolvedCbs.push(() => {
          queueMicroTask(() => {
            try {
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (err) {
              reject(err);
            }
          });
        });
        this.rejectedCbs.push(() => {
          queueMicroTask(() => {
            try {
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject);
            } catch (err) {
              reject(err);
            }
          });
        });
      }
    });
    return promise2;
  }
  catch(fn) {
    return this.then(null, fn);
  }
  finally(callback) {
    return this.then(
      (value) => {
        return Promise.resolve(callback()).then(() => value);
      },
      (reason) => {
        return Promise.resolve(callback()).then(() => {
          throw reason;
        });
      }
    );
  }
}
```

```js [resolvePromise]
const resolvePromise = (promise2, x, resolve, reject) => {
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
  if (promise2 === x) {
    return reject(
      new TypeError("Chaining cycle detected for promise #<Promise>")
    );
  }
  // Promise/A+ 2.3.3.3.3 只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if ((typeof x === "object" && x != null) || typeof x === "function") {
    try {
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
      let then = x.then;
      if (typeof then === "function") {
        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
        then.call(
          x,
          (y) => {
            // 根据 promise 的状态决定是成功还是失败
            if (called) return;
            called = true;
            // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
            resolvePromise(promise2, y, resolve, reject);
          },
          (r) => {
            // 只要失败就失败 Promise/A+ 2.3.3.3.2
            if (called) return;
            called = true;
            reject(r);
          }
        );
      } else {
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
        resolve(x);
      }
    } catch (e) {
      // Promise/A+ 2.3.3.2
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4
    resolve(x);
  }
};
```

```js [全局api]
class MyPromise {
  static resolve(data) {
    return new MyPromise((resolve, reject) => {
      resolve(data);
    });
  }
  static reject(reason) {
    return new MyPromise((resolve, reject) => {
      reject(reason);
    });
  }
  static all(promiseList) {
    const p1 = new MyPromise((resolve, reject) => {
      const result = []; // 存储 promiseList 所有的结果
      const length = promiseList.length;
      let resolvedCount = 0;

      promiseList.forEach((p) => {
        p.then((data) => {
          result.push(data);

          // resolvedCount 必须在 then 里面做 ++
          // 不能用 index
          resolvedCount++;
          if (resolvedCount === length) {
            // 已经遍历到了最后一个 promise
            resolve(result);
          }
        }).catch((err) => {
          reject(err);
        });
      });
    });
    return p1;
  }
  static race(promiseList) {
    let resolved = false; // 标记
    const p1 = new Promise((resolve, reject) => {
      promiseList.forEach((p) => {
        p.then((data) => {
          if (!resolved) {
            resolve(data);
            resolved = true;
          }
        }).catch((err) => {
          reject(err);
        });
      });
    });
    return p1;
  }
}
```

:::
