# Promise 和 async 函数

## 事件循环

JavaScript 是单线程的，为了同时处理异步任务，引入了事件循环机制。

整个执行过程是这样的：

1. 同步代码会在主线程中按顺序执行，这些代码进入调用栈（Call Stack）。
2. 当遇到异步任务，比如 setTimeout 或 Promise.then 时，JS 引擎不会立即执行它们，而是交给宿主环境（浏览器）处理。
3. 等异步任务准备好后，浏览器会把它们的回调函数分别放入不同的任务队列
4. 当主线程的同步任务执行完、调用栈清空后，事件循环就会先检查微任务队列，把里面的所有微任务一次性执行完。
5. 微任务清空之后，浏览器会在这时机会上进行一次 DOM 渲染（如果有更新）
6. 事件循环从宏任务队列中取出一个任务放入调用栈，执行它的同步代码，再进入下一轮循环

### 微任务 vs 宏任务

call stack 空闲，DOM 会尝试渲染变更后的 DOM 结构。渲染完成后才会触发下一次的 event loop。

- 微任务：Promise,async...await,MutationObserver
- 宏任务：setTimeout,setInterval,ajax 请求,DOM 事件

> 执行时机：微任务比宏任务早执行

## promise

将 callback 的形式从嵌套变成了管道形式（非嵌套），可以进行链式调用。

### promise 加载图片

如何解决回调地狱示例

```javascript
function loadImg(src) {
  return new Promise((resolve, reject) => {
    const img = document.createElement("img");
    img.onload = () => {
      resolve(img);
    };
    img.onerror = () => {
      reject("加载图片失败");
    };
    img.src = src;
  });
}
//非嵌套式调用
loadImg(url1)
  .then((img) => {
    console.log(img.width);
    return img; //返回普通对象
  })
  .then((img) => {
    console.log(img.height);
    return loadImg(url2); //返回promise对象
  })
  .then((img2) => {
    console.log(img2.width);
  });
```

### then/catch

then/catch 回调函数默认都返回 resolved 状态的 promise,如果有报错比如 throw error 则返回 rejected 状态的 promise;

如果返回了一个整数，则表示 resolved 回来的值是这个整数。

```javascript
Promise.resolve()
  .then(() => {
    console.log("resolve1");
    return { a: 100 };
  })
  .then((res) => {
    console.log("resolve2", res); //{a:100}
  })
  .then((res) => {
    console.log(res); //undefined
  });
```

## async await

优势：promise 基于回调函数，而 async await 是同步语法，彻底消灭了回调函数

特点：

1. async 函数默认返回 Promise 对象，如果返回的是原始类型值，相当于返回 Promise.resolve(xx)
2. await 相当于 Promise.then，await 后面的所有内容都可以看作是回调函数的内容(异步)
3. 使用 try...catch 捕获异常

```javascript {3}
async function async1() {
  console.log("async1 start"); //2
  await async2();
  // 下面的为异步代码
  console.log("async1 end"); //5
}
async function async2() {
  console.log("async2"); //3
}
console.log("script start"); //1
async1();
console.log("script end"); //4
```

上述代码中，高亮部分会先执行 async2,再执行 await,await 后面的代码都是异步代码

```js
async function fn() {
  return 100;
}

!(async function () {
  const a = fn();
  const b = await fn();
  console.log(a); //a为resolved状态的promise对象
  console.log(b); //b为100
})();
```

## promise A+规范

Promise 的核心可以总结为两件事：状态管理和 then 返回值解析。Promise 有三种状态：pending、fulfilled 和 rejected，状态不可逆。每次调用 then 都会返回一个新的 Promise，实现链式调用。then 回调的返回值决定下一个 Promise 的状态

- 普通值，则他返回的 promise 状态为 resolved 状态
- promise,则他返回的 promise 状态取决于 then 返回的 promise
- thenable 对象，则按照 promise 去解析
- 自身，为了避免循环引用这里会报 type error

## 手写 promise

核心功能：

1. 初始化和异步调用
2. then/catch 链式调用
3. 核心 api：resolve,reject,all,race

::: code-group

```js [构造函数]
class MyPromise {
  state = "pending";
  value = undefined;
  reason = undefined;
  resolveCallbacks = [];
  rejectCallbacks = [];

  constructor(fn) {
    const resolveHandler = (value) => {
      queueMicrotask(() => {
        if (this.state === "pending") {
          this.state = "fulfilled";
          this.value = value;
          this.resolveCallbacks.forEach((fn) => fn(value));
        }
      });
    };

    const rejectHandler = (reason) => {
      queueMicrotask(() => {
        if (this.state === "pending") {
          this.state = "rejected";
          this.reason = reason;
          this.rejectCallbacks.forEach((fn) => fn(reason));
        }
      });
    };

    try {
      fn(resolveHandler, rejectHandler);
    } catch (err) {
      rejectHandler(err);
    }
  }
}
```

```js [then实现]
class MyPromise {
  then(fn1, fn2) {
    fn1 = typeof fn1 === "function" ? fn1 : (v) => v;
    fn2 =
      typeof fn2 === "function"
        ? fn2
        : (e) => {
            throw e;
          };

    const handleCallback = (callback, resolve, reject, isRejected = false) => {
      queueMicrotask(() => {
        try {
          const result = callback(isRejected ? this.reason : this.value);
          resolve(result);
        } catch (err) {
          reject(err);
        }
      });
    };

    if (this.state === "pending") {
      const p1 = new MyPromise((resolve, reject) => {
        this.resolveCallbacks.push(() => handleCallback(fn1, resolve, reject));

        this.rejectCallbacks.push(() =>
          handleCallback(fn2, resolve, reject, true)
        );
      });
      return p1;
    }

    if (this.state === "fulfilled") {
      const p1 = new MyPromise((resolve, reject) =>
        handleCallback(fn1, resolve, reject)
      );
      return p1;
    }

    if (this.state === "rejected") {
      const p1 = new MyPromise((resolve, reject) =>
        handleCallback(fn2, resolve, reject, true)
      );
      return p1;
    }
  }
}
```

```js [全局api]
MyPromise.resolve = function (value) {
  return new MyPromise((resolve, reject) => resolve(value));
};
MyPromise.reject = function (reason) {
  return new MyPromise((resolve, reject) => reject(reason));
};

MyPromise.all = function (promiseList = []) {
  const p1 = new MyPromise((resolve, reject) => {
    const result = [];
    const length = promiseList.length;
    let resolvedCount = 0;

    promiseList.forEach((p) => {
      p.then((data) => {
        result.push(data);
        // resolvedCount 必须在 then 里面做 ++
        // 不能用 index
        resolvedCount++;
        if (resolvedCount === length) {
          // 已经遍历到了最后一个 promise
          resolve(result);
        }
      }).catch((err) => {
        reject(err);
      });
    });
  });
  return p1;
};

MyPromise.race = function (promiseList = []) {
  let resolved = false; // 标记
  const p1 = new Promise((resolve, reject) => {
    promiseList.forEach((p) => {
      p.then((data) => {
        if (!resolved) {
          resolve(data);
          resolved = true;
        }
      }).catch((err) => {
        reject(err);
      });
    });
  });
  return p1;
};
```

:::
