# BOM 和事件

浏览器信息：`navigator.userAgent`

location:

- location.pathname
- location.search
- location.hash

## 事件冒泡

含义：父元素和后代元素绑定了同一类型的事件，会先从后代元素触发，最终触发最上层元素绑定的回调函数

阻止冒泡：`event.stopPropagation()`

## 事件代理

含义：将事件绑定到统一的父元素上，利用事件冒泡机制实现事件绑定的同时减少内存消耗，通过 `event.target` 获取到实际触发的元素

场景：瀑布流布局，无限往下加载更多

封装：

```js
function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector;
    selector = null;
  }
  elem.addEventListener(type, (event) => {
    let target = event.target;

    if (selector) {
      if (target.matches(selector)) {
        fn.call(target, event);
      }
    } else {
      fn.call(target, event);
    }
  });
}
```

## 浏览器的同源策略

限制对象：ajax 请求

同源：协议+域名+端口

不受同源策略限制：

- 图片加载`<img src/>`，可以用于第三方统计打点
- css 加载`<link rel="stylesheet" href-="index.css"></link>`，可以用于 CDN
- js 加载`<script src='xx.js'></script>`,可以用于 CDN

解决方案：

### jsonp

原理：

1. script 可以绕过跨域限制
2. 服务端可以拼接成一段可执行的 JS 调用代码
3. script 借助 window.callback 可以获取跨域数据

::: code-group

```html [客户端]
<script>
  window.cb = (data) => {
    console.log(data);
  };
</script>
<script src="getData.js?callback=cb"></script>
```

```js [服务端]
cb({ x: 123, y: 456 });
```

:::

### cors

服务器端设置响应头

```js
response.setHeader("Access-Control-Allow-Origin", "");
response.setHeader("Access-Control-Allow-Headers", "");
response.setHeader("Access-Control-Allow-Methods", "");
//接受跨域cookie
response.setHeader("Access-Control-Allow-Credentials", true);
```

## 本地存储

- cookie-4kb,随 http 请求发送，会增加请求数据量
- storage:5MB，不随着 http 请求发送，有 getItem/setItem 方法
  - localStorage：永久性存储，除非代码或者手动删除
  - sessionStorage:非永久性，浏览器窗口关闭则清空
