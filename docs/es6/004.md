# 变量类型和计算

## 变量类型

按照 ES6 标准划分：

1. 基本类型：string,number,boolean,bigint,symbol,undefined,null
2. 对象类型: object,array,function

### 数据类型

按照存储划分:

1. 值类型：变量值存储在向下生长的栈中，比如除了 null 以外的基本数据类型
   ![值类型](./imgs/004_smple.jpg)
2. 引用类型：栈上的变量保存的是“指向堆中对象的地址”，而非对象本体，对象实际被保存在向上生长的堆中，比如对象、数组；null 是特殊引用类型，但指针指向空地址
   ![引用类型](./imgs/004_complex.jpg)
3. 函数类型：特殊的引用类型

```javascript
let a = 100;
let b = a;
a = 300;
console.log(b); //100，修改变量值不会互相干扰

let c = { age: 299 };
let d = c;
d.age = 100;
console.log(c); //{age:100},修改变量值会互相干扰
```

> 之所以需要分开存储是因为对象通常需要占用很大内存，只有堆能满足。

### typeof

1. 识别所有的值类型和函数类型
2. 识别是否为引用类型，但无法具体到数组或者对象

### 引用类型的浅拷贝/深拷贝

- 浅拷贝:只能复制对象或数组的第一层属性/元素，修改深层属性会互相影响
  - 展开运算符 `const a={...b}`
  - Object.assign()方法
- 深拷贝:会复制对象或数组的所有属性/元素，修改深层元素属性不会互相影响

  - ​`​JSON.parse(JSON.stringify(obj))​​`:适合纯 json 场景
  - `​​lodash.cloneDeep()`:适合大型项目使用
  - `structuredClone()`：适合现代浏览器/Node.js 环境中需要可靠深拷贝且不含函数的场景
  - 手动递归复制

  ```javascript
  function deepClone(obj) {
    //要点1：判断值类型和引用类型
    if (typeof obj !== "object" || obj == null) {
      return obj;
    }

    // 要点2：判断数组or对象
    let result = Array.isArray(obj) ? [] : {};

    //要点3：递归
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = deepClone(obj[key]);
      }
    }
    return result;
  }
  ```

手动递归复制存在循环引用问题，会出现栈溢出报错，可以使用 weakMap 解决

```javascript
function deepClone(obj, visited = new WeakMap()) {
  // 基本类型或函数：直接返回（不克隆函数）
  if (obj === null || typeof obj !== "object") return obj;

  // 断环：已访问过则直接复用副本
  if (visited.has(obj)) return visited.get(obj);

  // 创建新容器并先登记，避免子递归时重复进入造成栈溢出
  const copy = Array.isArray(obj) ? [] : {};
  visited.set(obj, copy);

  // 仅遍历自有可枚举属性（不走原型链、不处理 Symbol）
  for (const key in obj) {
    if (Object.hasOwn(obj, key)) {
      copy[key] = deepClone(obj[key], visited);
    }
  }

  return copy;
}
```

或者使用迭代代替递归实现

```javascript
function cloneT(o) {
  return Array.isArray(o) ? [] : {};
}
function copy2(obj) {
  if (typeof obj !== "object" || obj === null) return obj;

  const cache = new WeakMap(); // 源对象 -> 副本的映射，断环并保同一性
  const tasks = []; // 待处理的源对象队列

  // 创建根副本并建立映射
  const cp = Array.isArray(obj) ? [] : {};
  cache.set(obj, cp);
  tasks.push(obj);

  while (tasks.length) {
    const src = tasks.shift(); // 取出一个源对象
    const dst = cache.get(src); // 取出已创建的唯一副本

    // 遍历其所有可枚举自有属性（不含 Symbol）
    for (const key in src) {
      if (!Object.hasOwn(src, key)) continue;
      
      const v = src[key];

      if (v !== null && typeof v === "object") {
        if (cache.has(v)) {
          // 已访问过：直接复用同一副本
          dst[key] = cache.get(v);
        } else {
          // 首次访问：创建对应类型的空壳并建立映射，再入队继续处理
          const child = Array.isArray(v) ? [] : {};
          cache.set(v, child); // 👈 关键：先登记，再入队
          dst[key] = child;
          tasks.push(v);
        }
      } else {
        // 基本类型直接赋值
        dst[key] = v;
      }
    }
  }

  return cp;
}
```
