# let/const

## let

### 作用域

- ES5:全局作用域+函数作用域
- ES6:ES5 作用域+块级作用域

let 声明的变量只在变量声明所在块级作用域内有效，否则会报错`reference error:xx is not defined`;var 声明的变量在全局范围内有效

```javascript
for (var i = 0; i < 10; i++) {
  arr[i] = function () {
    console.log(i);
  };
}
arr[6](); //打印结果为10

for (let i = 0; i < 10; i++) {
  arr[i] = function () {
    console.log(i);
  };
}
arr[6](); //打印结果为6
```

第一个循环最后打印结果为 10，原因如下：

1. 变量 i 的作用域是全局，而不是每次循环的块级作用域，循环时只是定义了一个函数，实际执行的时候 i 已经是 10
2. arr[i]存储的函数是典型的闭包，保存的是对变量 i 的引用 ​​，而不是循环时的瞬时值，调用时，i 的值已经变成 10

> 闭包（Closure）是指函数可以访问并记住其词法作用域（lexical scope）外的变量 ​​，即使该函数在其原始作用域之外执行

解决方案：

1. 使用 let 定义循环变量
2. 使用 IIFE 函数，即声明后立刻执行

```javascript
var arr = [];
for (var i = 0; i < 10; i++) {
  (function (j) {
    arr[j] = function () {
      console.log(j); // 固定为当前 j
    };
  })(i);
}
arr[8];
```

> 函数内部变量（包括形参、局部变量、闭包引用的外部变量）的值是在运行时（调用时）确定 ​​，但他们的作用域（可访问性）是在定义时（词法作用域）确定的

### 变量提升

- ES5:声明变量 var，可以变量提升，即先使用后声明，值为 undefined,内部声明的同名变量会覆盖外部声明的变量
- ES6:声明变量 let，不支持变量提升,减少运行时错误

```javascript
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
function f1() {
  var n = 5;
  if (true) {
    var n = 10;
  }
  console.log(n); // 10
}
```

### 暂时性死区

let 变量声明之前使用都属于暂时性死区，导致 typeof 不是完全安全
::: code-group

```javascript [TZD1]
var tmp = 2;
if (true) {
  temp = "abc";
  let tmp;
  console.log(tmp, "2"); //undefined
}
console.log(tmp, "1"); //2
```

```javascript [TZD2]
function bar(x = y, y = 2) {
  console.log(x);
}
//报错Uncaught ReferenceError: Cannot access 'y' before initialization
bar();
function bar2(x = 2， y = x) {
  console.log(x);
}
//不报错
bar2();
```

:::

### 重复声明

var 可以重复声明变量，let 不可以在同级作用域内重复声明变量

## const

用于定义常量，必须声明后立刻赋值，且后续不能修改；只在声明所在的块级作用域内有效，不支持变量提升，存在暂时性死区

const 可以保证变量指向的内存地址所保存的数据不变

- 简单数据类型：内存地址保存的数据就是变量的值，等同于常量
- 复杂数据类型：内存地址保存的只是指向实际数据的指针，指针指向的实际值不能保证不变

```javascript
const foo = {};
// 为 foo 添加一个属性，可以成功
foo.prop = 123;
console.log(foo.prop); // 123
// 重新赋值，报错
foo = { props: 122 };
```

解决方法：冻结对象`Object.freeze()`可以在添加新属性的时候不生效

## 顶层对象属性

- 浏览器：window
- Node：global

ES5 内用 var 声明的变量会自动成为顶层对象的属性；ES6 里用 let 声明的变量不会自动成为顶层对象的属性
