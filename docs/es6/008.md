# TypeScript(1)

优点：

1. 静态类型
2. 在编译时就会报错，而非运行时报错
3. 智能提示提升了开发效率和稳定性

缺点：

1. 学习成本
2. 某些时候，类型定义过于复杂，可读性差
3. any 滥用，类型检查失效

适用场景：

- 大项目，业务复杂，维护人员多
- 逻辑性强的代码，需要类型更稳固
- 有一个 leader 角色能够掌控代码规范

---

基础类型：同 JS
其他类型：

- 枚举 enum:编译后会变成一个 JavaScript 对象
- 数组 Array:`const a=Array<number>[1,2]`
- 元组 Tuple:`type StringNumberPair = [string, number,string?,boolean?]`

  > 二者区别是元组的元素数量是事先指定的，支持可选元素，而普通数组的元素数量是未知的

## ts 中的 any.void.never.unknown

- any：不进行类型检查
- void:没有类型，函数类型定义中没有返回值使用
- never:永远不存在的类型
- unknown:未知类型，更加安全的 any，可以定义值，但不能操作值；后续只能通过`as`转换为需要的类型

## 访问修饰符

1. public:默认，全部可访问
2. protected:自己和派生类可访问
3. private:只有自己可访问

#私有属性和 private 的区别：

1. #属性不能在 class 的构造函数中定义，而 private 可以
2. private 可以通过 as any 方式强制获取，而#属性任何情况下都不能获取

## interface vs type

共同点:

1. 都可以描述一个对象结构
2. 都可以被 class 实现
3. 都具备扩展性

```ts
interface User {
  name: string;
  age: number;
  getAge: () => number;
}

type UserType = {
  name: string;
  age: number;
  getAge: () => number;
};
const user: UserType = {
  name: "yChannelSelector",
  age: 18,
  getAge: () => {
    return 132;
  },
};
// UserClass必须满足User的类型结构
class UserClass implements User {
  name = "sessionStorage";
  age = 10;
  getAge = () => {
    return this.age;
  };
}
```

区别：

1. type 声明类型需要赋值符号，而 interface 不需要
2. type 可以声明基础类型，支持使用联合类型和交叉类型的结果定义新类型
3. type 可以通过 `typeof 变量名` 提取值的类型
4. interface 会自动合并声明，type 不行
5. interface 通过 extends 关键字扩展属性，type 通过联合/交叉等方法扩展属性

选择： 都可以的情况下优先选择 interface

## 泛型

本质：解决代码通用性问题

```ts
//类型声明添加泛型
type User2<T> = {
  name: T;
  age: number;
};
//需要类型中必须有某个属性
type User2<T extends { length: number }> = {
  name: T;
  age: number;
};

const n: User2<number[]> = {
  name: [1, 2, 4],
  age: 67,
};
//函数添加泛型
function fn1<T, U>(a: T, b: U): [U, T] {
  return [b, a];
}

const fn2 = <T, U>(a: T, b: U): [U, T] => {
  return [b, a];
};
// class添加泛型
class Name<T> {
  constructor(name: T) {
    this.name = name;
  }
  getName = (): T => {
    return this.name;
  };
  getInfo(): T {}
}
```

## 交叉类型&联合类型

交叉类型：通过`&`实现，将多个类型合并为 1 个类型，取交集

联合类型：通过 `|` 实现，可获取多个类型的所有属性，取并集

## 工具类型

1. Partial<T>:将 T 所有属性变为可选属性
2. Required<T>:将 T 所有属性变为必须属性
3. Pick<T,"k1"|"k2">:从 T 选取对应属性
4. Omit<T,"K1"|"K2">:从 T 排除对应属性
5. ReadOnly<T>:将 T 所有属性变为只读
6. Exclude<Union,'k1'|'k2'>:从联合类型中排除对应属性
7. Extract<Union，'k1'|'k2'>:从联合类型中提取对应属性
8. Parameters<Fn>:获取函数的参数类型，返回一个 元组类型（tuple）
9. ReturnType<Fn>:获取函数的返回类型,返回单个值

## 扩展

创建 index.d.ts

### 扩展 windows 属性

`declare interface Windows{test:string}`

### 扩展第三方模块类型

如果本身就是用 TS 写的不需要处理，大部分第三方插件都会提供`@types/xxx`的包，安装即可。如果本身用 js 写且没有注释的话，使用`declare module ''{}`

```ts
/**
 * https://github.com/gxmari007/vite-plugin-eslint
 * 由于 vite-plugin-eslint 库有点落后，导致 vite 高版本不能正确的识别模块
 * 所以这里手动定义
 */
declare module "vite-plugin-eslint" {
  import { Plugin } from "vite";
  import { ESLint } from "eslint";

  /** Plugin options, extending from ESlint options */
  interface Options extends ESLint.Options {}

  const content: (rawOptions?: Options) => Plugin;
  export default content;
}
```
