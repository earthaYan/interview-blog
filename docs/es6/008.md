# 节流防抖

## 防抖 debounce：

原理：无论用户触发多少次事件，对应的回调函数只会在事件停止触发指定时间后执行。

场景：

```js
function debounce(fn, delay = 500, immediate = false) {
  let timer;
  return function (...args) {
    const context = this;

    if (timer) clearTimeout(timer);

    if (immediate&&) {
      const callNow = !timer; // 第一次立即执行
      timer = setTimeout(() => {
        timer = null; // 重置 timer
      }, delay);
      if (callNow) return fn.apply(context, args);
    } else {
      timer = setTimeout(() => {
        fn.apply(context, args);
      }, delay);
    }
  };
}

const debouncedFn = debounce(originalFn, delay);
element.addEventListener("event", debouncedFn);
```

## 节流 throttle

原理：无论用户触发事件多少次，回调函数只会按照给定的时间间隔执行一次

场景：与另一个持续更新的状态同步,

```js
function throttle(fn,delay){
    let timer
    return function(fn.delay){
        if(timer) return
        timer=setTimeout(()=>{
            fn.apply(this,arguments)
            timer=null
        },delay)
    }
}
```

::: tip
Q:将 timer 设置为 null，和 clearTimeout(timer)有什么区别

A:clearTimeout 是用来取消定时器的，回调不会执行，但 timer 变量依然保存定时器 ID；而 timer = null 只是把变量清空，不会影响定时器，回调还是会执行。
:::
