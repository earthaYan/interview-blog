# 作用域和闭包

## 作用域&自由变量

作用域分为：全局作用域,函数作用域,块级作用域

自由变量：在当前作用域内未定义的变量，需要向上层作用域逐层寻找

> 自由变量的查找，是在函数定义的地方向上层作用域查找，而不是在函数执行的地方向上查找

## 闭包

形式：函数作为参数传入或者返回值，且这些函数访问了其定义时的作用域中的变量时，才形成闭包

核心：函数可以访问其定义时的作用域中的变量，即使函数在其原始作用域之外被调用。

::: code-group

```javascript [典型]
function outer() {
  let count = 0;
  function inner() {
    count++;
    console.log(count);
  }
  return inner;
}
const counter = outer();
counter(); // 输出: 1
counter(); // 输出: 2
```

```javascript [参数传入]
function print(fn) {
  const a = 200;
  fn();
}

const a = 100;
function fn() {
  console.log(a);
}
print(fn); //100
```

```javascript [返回值返回]
function create() {
  const a = 100;
  return function () {
    console.log(a);
  };
}

let fn = create();
fn(); //100
```

:::

### 实际使用场景

1. cache 管理：隐藏内部数据，只提供 API

```javascript
function createCache() {
  const data = {};
  return {
    set: function (key, value) {
      data[key] = value;
    },
    get: function (key) {
      return data[key];
    },
  };
}
const c = createCache();
c.set("name", "alice");
const a = c.get("name");
```

2. 函数柯里化：封装 fetch 请求

```javascript
function createAPIRequest(baseURL) {
  return function (endpoint) {
    return function (params = {}) {
      return fetch(`${baseURL}${endpoint}`, {
        method: "POST",
        body: JSON.stringify(params),
      });
    };
  };
}

const api = createAPIRequest("https://api.example.com");
const getUser = api("/user");

// 使用配置好的函数
getUser({ id: 123 });
```

3. react hooks：保存和管理组件的状态与副作用

- 每次渲染都有独立的闭包 ​
- 依赖项是闭包的更新开关

```javascript
function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value; // 在渲染后更新ref
  }, [value]); // 值变化时更新

  return ref.current; // 返回闭包中保存的上一个值
}

// 使用
function Component() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      当前: {count}, 之前: {prevCount}
    </div>
  );
}
```

4. 节流防抖

### react 中的闭包陷阱

- useState

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  const handleClick = () => {
    setTimeout(() => {
      setCount(count + 1);
    }, 1000);
  };
  const handleReset = () => {
    setCount(0);
  };
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

handleClick 函数形成了一个闭包，可以访问 Counter 函数中定义的 count 状态值和 setCount 函数；本意是点击按钮后，计数器定时增加，但实际上，无论怎么点击都是 1。

原因是 setCount 所接收的 count 值是在闭包中被缓存的值，这个值始终不变。1s 后 setTimeout 中的 setCount 生效，函数式组件 Counter 重新执行，会生成新的 handleClick 方法，形成新的闭包。

此时闭包中缓存的 count 值也就变成了最新的 count 值再继续点击 Increment 按钮，又会重复上述循环，每过 1s count 值会加 1

解决方案是 setCount 方法传入一个函数

- useEffect

## this 指向

1. 在普通函数使用：指向全局 window
2. 在对象的方法中使用：指向对象
3. 在 class 中使用：指向类的实例
4. 箭头函数中使用：指向函数定义时的上一层的作用域中的 this 对象
5. 使用 bind/call/apply:指向绑定的对象

::: tip
this 取值是在函数执行的时候确认，而不是定义的时候确认
:::

需要注意的是在 setTimeout 的回调函数中，this 通常会指向全局，所以建议优先使用箭头函数固定 this 指向

## 手写 bind 函数

```javascript
Function.prototype.bind1 = function () {
  // 参数转换为数组
  const args = Array.prototype.slice.call(arguments);
  //获取this
  const t = args.shift();
  //fn.bind()中的fn
  const self = this;
  //返回一个函数
  return function () {
    return self.apply(t, args);
  };
};
```

由于 arguments 是一个类数组，所以不能直接使用`arguments.slice()`

## 手写 apply

```javascript
Function.prototype.apply1 = function (context, argsArray) {
  context = context || globalThis;
  const fnSymbol = Symbol();
  context[fnSymbol] = this;

  let result;
  if (argsArray == null) {
    // 没传参数
    result = context[fnSymbol]();
  } else if (!Array.isArray(argsArray)) {
    // 传入的不是数组
    throw new TypeError("apply 第二个参数必须是数组或类数组");
  } else {
    result = context[fnSymbol](...argsArray);
  }

  delete context[fnSymbol];
  return result;
};
```

## 手写 call

```javascript
Function.prototype.call1 = function (context, ...args) {
  // 1. context 可能是 null 或 undefined，此时默认指向全局对象（浏览器是 window）
  context = context || globalThis;

  // 2. 给 context 临时添加一个属性，指向当前函数（this 即被调用的函数）
  const fnSymbol = Symbol(); // 用 Symbol 防止属性名冲突
  context[fnSymbol] = this;

  // 3. 执行函数
  const result = context[fnSymbol](...args);

  // 4. 删除临时属性
  delete context[fnSymbol];

  // 5. 返回执行结果
  return result;
};
```
