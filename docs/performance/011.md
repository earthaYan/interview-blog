---
outline: deep
---

# web 动画优化

## 动画实现方式

1. 位置类属性:`position`,`top`
2. 合成友好属性:`transform:translate/scale/rotate`，`opacity`，`will-change:transform/opacity`

两种方式视觉效果一致，但是性能上是完全不同的浏览器内部流程。

通过 transform 等属性可以把元素提升为一个独立图层，图层只需要绘制一次，然后后续每一帧都只需要在 GPU 合成线程上改变图层的变化矩阵，即只做合成，不会触发重排重绘，减轻 CPU 压力，让主线程可以处理其他任务。

合成线程独立于主线程，即使主线程在执行 JS 导致暂时阻塞，合成线程上的动画仍然能保持流畅。

## css 动画 和 js 动画

css 动画性能更好是因为 css 可以将工作负载从主线程转移到合成线程

### 线程分类

1. 主线程：JS 执行、布局/样式计算、页面绘制、处理用户交互，一旦被阻塞整个页面就会卡顿无响应
2. 合成线程：相对独立，合并绘制好的各个图层并显示在屏幕上，**独立于主线程**

### 最佳实践

用 js 切换状态(css 类名)，css 执行动画。

## will-change 属性

作用：主动告知浏览器为接下来的变化提前做准备

最佳实践：

1. 默认不使用，只有遇到实际性能问题再启用
2. 通过 js 切换按需应用，交互发生前添加，动画结束后移除
3. 明确指定属性 transform/opacity，而不是`will-change:all`

::: code-group

```css [will-change]
.card {
  transition: transform 0.3s ease-out;
}
.card-is-changing {
  will-change: transform;
}
```

```js [动态控制]
card.addEventListener("mouseenter", () => {
  card.classList.add("card-is-changing");
});
card.addEventListener("transitionend", () => {
  card.classList.remove("card-is-changing");
});
```

:::
