# 长连接-SSE

SSE:类似于单向的 websocket，可以让服务端主动给前端发送消息

## 本质

以可读流的形式逐个按字节给前端传输文本，期间 http 连接一直保持，所以服务端可以一直通过连接推送消息

## 区别

- SSE 基于 `http(s)`协议，websocket 基于`ws`协议，占用的服务器资源和后端开发复杂度远小于 ws,
- SSE 只能服务端给前端发消息，前端不能通过 SSE 给服务端发送

## SSE 使用场景

> 和后端实时通讯只需要后端给前端

- 实时获取定位
- 未读消息
- ai 工具常用的流式输出

## 服务端实现 node+express

1. 开启一个 http 服务
2. 定义一个 get 接口
3. 设置 content-type 为`text/event-stream;charset=utf-8`
4. 每次向响应写入数据就会往前端发一个消息，调用 end 结束响应就会断开(但断开，前端会主动重新连接)

```js
const express = require("express");
const cors = require("cors");

const app = express();
app.use(cors());
app.get("/api/sse", (req, res) => {
  res.writeHead(200, {
    "Content-Type": "text/event-stream;charset=utf-8",
    Connection: "keep-alive",
  });
  console.log("收到连接");
  let counter = 0;
  const interval = setInterval(() => {
    const arr = ["你好", "啊", "ss", "e", "h", "e", "lp", "me"];
    res.write(arr[counter]);
    counter++;
    if (counter >= arr.length) {
      clearInterval(interval);
    }
  }, 1000);
  req.on("close", () => {
    console.log("客户端主动断开连接");
    clearInterval(interval);
    res.end();
  });
});
app.listen(3000, () => {
  console.log("服务器已开始运行");
});
```

## 客户端实现

1. 创建 EventSource 对象，传入接口地址
2. 通过 onmessage 可以监听消息，通过 onopen 可以监听连接上的那一刻，onclose 可以监听断开

```jsx
import { useEffect, useState } from "react";

const App = () => {
  const [message, setMessage] = useState("");
  useEffect(() => {
    const eventSource = new EventSource("http://localhost:3000/api/sse");
    eventSource.onmessage = (valueText) => {
      console.log(valueText.data);
      setMessage((prev) => prev + valueText.data);
    };
    return () => {
      eventSource.close();
    };
  }, []);

  return <>{message}</>;
};

export default App;
```

## 问题 1：接口正常返回，但 onmessage 未被触发

原因：

1. 对于浏览器自带的 EventSource 接口侧必须严格按照`data: 内容/n/n`格式写入，否则前端无法触发 onmessage
2. 服务器不能主动断开，会导致前端无法重连，前端也是一样，只能重新创建实例

```js
res.write(`data:` + arr[counter] + "\n\n");
```

## 最佳实践

1. 同一个接口可以通过 event 来定义承载各种不同的功能，最大程度复用

```js
//后端
if (counter >= arr.length) {
  //结束之后发不同的消息
  res.write("event:newMessage\n");
  res.write("data:你有一个未读消息\n\n");

  clearInterval(interval);
}
//前端
eventSource.addEventListener("newMessage", (event) => {
  console.log(event.data);
});
```

2. 和定时器、全局监听一样，组件卸载的时候需要做清除操作
3. 现实工作中是需要 token 鉴权的，但是原生 eventSource **不能修改请求头**，

   - 解决方案 1：把 token 放在请求地址上,后端用 query 获取，但不安全
   - 解决方案 2：用 cookie 携带 token，如果服务端用了 jwt 则该方法无效
   - 解决方案 3：如果必须放在请求头，就只能自定义 sse 客户端或者使用第三方库`event-source-polyfill`
     ::: code-group

```js [自定义SSE]
export class MySSE {
  constructor(url) {
    this.url = url;
    this.init();
  }
  onmessage(valueText) {
    console.log(valueText);
  }
  async init() {
    // 也可以用axios
    const res = await fetch(this.url, {
      method: "GET",
      headers: {
        "content-type": "text/event-stream",
        token: localStorage.getItem("token") || "1111",
      },
    });
    // res是一个流
    const reader = res.body.getReader();
    //文本编码对象，把buffer转为文本
    const decoder = new TextDecoder();
    while (true) {
      // value本次读取到的值
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      const valueText = decoder.decode(value, { stream: true });
      //这里可以自定义开头，符合这个开头才会解析
      if (valueText.startsWith("data:")) {
        this.onmessage(valueText);
      }
    }
  }
}
```

```js [第三方库]
import { useEffect, useState } from "react";
import { EventSourcePolyfill } from "event-source-polyfill";

const App = () => {
  const [message, setMessage] = useState("");
  useEffect(() => {
    const eventSource = new EventSourcePolyfill(
      "http://localhost:3000/api/sse",
      {
        headers: {
          token: localStorage.getItem("token") || "1111e",
        },
      }
    );
    eventSource.onmessage = (data) => {
      setMessage((prev) => prev + data.data);
    };
    return () => {
      eventSource.close();
    };
  }, []);

  return <>{message}</>;
};

export default App;
```

:::
