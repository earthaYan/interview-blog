---
outline: deep
---

# 减少重排和重绘

## 浏览器渲染

1. 浏览器从网络获取 html/css/js 资源
2. 渲染关键步骤：
   - 解析 html,构建 DOM 树
   - 解析 css，构建 CSSOM 树
   - 结合 DOM 和 CSSOM，生成 render 树
   - Layout:浏览器计算每个可见节点的几何信息(尺寸、位置)
   - Paint:浏览器为每个节点绘制颜色、边框、文字
   - Composite:多图层合成，输出到屏幕

> Layout 和 Paint 会导致重排(reflow)和重绘(repaint)

## 重绘 repaint

定义：仅改变视觉样式，不改变几何布局

属性：color,background-color,box-shadow,visibility

特点：不触发布局计算，性能开销中等，但在动画或者高频交互中不断触发重绘可能会导致页面卡顿

## 重排 reflow

定义：DOM 结构或者元素几何属性发生变化的操作

属性：尺寸 width/padding/border,位置 top/margin/position、display

特点：性能开销高，必须重算受影响区域的布局；而且重排一定会触发重绘

## 常规措施

1. 样式和行为分离：将样式变更聚合到一个 class 里，js 只执行添加类名的操作，避免多次写操作
2. 批量 DOM 更新：使用`document.createDocumentFragment`一次性修改 DOM 结构，最终只触发一次重排
3. `display:none`,会从渲染树中移除，隐藏后批量修改，修改后显示，但切换 display 会触发重排，所以只适合修改量大但频率低的场景
4. 读写分离：频繁读写交错会让浏览器被迫多次即时重排，也就是典型的布局抖动，所以实际开发中应该将频繁读和频繁写拆分开来
5. 避免在动画中频繁读取布局属性：几何测量放在动画开始或者节流后的回调中
6. 使用`requestAnimation`在一帧开始集中读，在回调中集中写

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>requestAnimationFrame 动画示例</title>
    <style>
      #box {
        width: 100px;
        height: 100px;
        background-color: red;
        position: absolute;
        top: 50px;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="box"></div>

    <script>
      const box = document.getElementById("box");
      let start = null; // 动画开始时间
      const duration = 2000; // 动画总时长（ms）
      const distance = 300; // 移动距离（px）

      function animate(timestamp) {
        if (!start) start = timestamp; // 初始化开始时间
        const elapsed = timestamp - start; // 已经过时间
        const progress = Math.min(elapsed / duration, 1); // 进度 0~1

        // 移动方块
        box.style.transform = `translateX(${distance * progress}px)`;

        // 改变颜色（从红到绿）
        const red = Math.round(255 * (1 - progress));
        const green = Math.round(255 * progress);
        box.style.backgroundColor = `rgb(${red}, ${green}, 0)`;

        if (progress < 1) {
          requestAnimationFrame(animate); // 下一帧继续动画
        }
      }

      requestAnimationFrame(animate); // 启动动画
    </script>
  </body>
</html>
```

## 合成层优化

合成层：将各个图层合并到一起，最终输出到屏幕

> 现代浏览器将部分元素提升到了合成层，对部分属性的修改只会发生在合成阶段

- transform:translate,scale,rotate
- opacity

优点：不会触发重排，也不需要重绘整个元素，由 GPU 加速，动画也更流畅

## react 中的布局抖动

在 useEffect 或者 componentDidMount 中，先测量 DOM,再立刻设置状态导致重新渲染，同时又在后续 effect 中继续读；另外在 useLayoutEffect 中读写交织容易触发同步布局

解决方案：尽量将 dom 读写放在同一个 effect 里处理，并且读写不要交织
